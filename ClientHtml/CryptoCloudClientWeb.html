<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width">
    <title>Web Client</title>
    <title></title>
    <link
        href="data:image/x-icon;base64,AAABAAEAEBAAAAAAAABoBAAAFgAAACgAAAAQAAAAIAAAAAEAIAAAAAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPgAAAD4AAAA+AAAAPgAAAD4AAAA+AAAAPgAAAD4AAAAAAAAAAAAAAAAAAAAA////AP///wD///8AAAAAPgAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAAPgAAAAD///8A////AP///wD///8AAAAAAAAAAP98fHz/6enp/3x8fP98fHz/fHx8/3x8fP98fHz/fHx8/wAAAP8AAAAA////AP///wD///8A////AAAAAAAAAAD/6enp/+np6f/p6en/6enp/+np6f/p6en/6enp/+np6f8AAAD/AAAAAP///wD///8A////AP///wAAAAAAAAAA/3x8fP/p6en/fHx8/3x8fP98fHz/fHx8/3x8fP98fHz/AAAA/wAAAAD///8AAAAAAP///wD///8AAAAAAAAAAP/p6en/6enp/+np6f/p6en/6enp/+np6f/p6en/6enp/wAAAP8AAAAA////AP///wD///8A////AAAAAAAAAAD/fHx8/+np6f98fHz/fHx8/3x8fP98fHz/fHx8/3x8fP8AAAD/AAAAAP///wD///8A////AP///wAAAAAAAAAA/+np6f/p6en/6enp/+np6f/p6en/6enp/+np6f/p6en/AAAA/wAAAAD///8A////AP///wD///8AAAAAAAAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP////8A////AP///wD///8A////AAAAAAAAAAAAAAAA/+np6f8AAAD/AAAAAAAAAAAAAAD/6enp/wAAAP8AAAAA////AP///wD///8A////AP///wD///8AAAAAAAAAAP/p6en/AAAA/wAAAD4AAAA+AAAA/+np6f8AAAD/AAAAAP///wD///8A////AP///wAAAAAA////AAAAAAAAAAD/6enp/3x8fP8AAAD/AAAA/3x8fP/p6en/AAAA/wAAAAD///8A////AP///wD///8AAAAAAP///wAAAAAAAAAA/3x8fP/p6en/6enp/+np6f/p6en/fHx8/wAAAP////8A////AP///wD///8A////AAAAAAD///8A////AAAAAAAAAAD/fHx8/+np6f/p6en/fHx8/wAAAP8AAAAA////AP///wD///8A////AP///wAAAAAA////AP///wD///8AAAAAAAAAAP8AAAD/AAAA/wAAAP8AAAAA////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wAAAAAAAAAAAAAAAAAAAAAA////AP///wD///8A////AP///wD///8A//8AAPAPAADgBwAA4AcAAOAHAADgBwAA4AcAAOAHAADgBwAA8Y8AAPGPAADwDwAA8A8AAPgfAAD8PwAA//8AAA=="
        rel="icon" type="image/x-icon" />
    <!-- Script required to view QR codes in the browser-->
    <script>
        // alignment pattern
        adelta = [
            0, 11, 15, 19, 23, 27, 31, // force 1 pat
            16, 18, 20, 22, 24, 26, 28, 20, 22, 24, 24, 26, 28, 28, 22, 24, 24,
            26, 26, 28, 28, 24, 24, 26, 26, 26, 28, 28, 24, 26, 26, 26, 28, 28
        ];

        // version block
        vpat = [
            0xc94, 0x5bc, 0xa99, 0x4d3, 0xbf6, 0x762, 0x847, 0x60d,
            0x928, 0xb78, 0x45d, 0xa17, 0x532, 0x9a6, 0x683, 0x8c9,
            0x7ec, 0xec4, 0x1e1, 0xfab, 0x08e, 0xc1a, 0x33f, 0xd75,
            0x250, 0x9d5, 0x6f0, 0x8ba, 0x79f, 0xb0b, 0x42e, 0xa64,
            0x541, 0xc69
        ];

        // final format bits with mask: level << 3 | mask
        fmtword = [
            0x77c4, 0x72f3, 0x7daa, 0x789d, 0x662f, 0x6318, 0x6c41, 0x6976,    //L
            0x5412, 0x5125, 0x5e7c, 0x5b4b, 0x45f9, 0x40ce, 0x4f97, 0x4aa0,    //M
            0x355f, 0x3068, 0x3f31, 0x3a06, 0x24b4, 0x2183, 0x2eda, 0x2bed,    //Q
            0x1689, 0x13be, 0x1ce7, 0x19d0, 0x0762, 0x0255, 0x0d0c, 0x083b    //H
        ];

        // 4 per version: number of blocks 1,2; data width; ecc width
        eccblocks = [
            1, 0, 19, 7, 1, 0, 16, 10, 1, 0, 13, 13, 1, 0, 9, 17,
            1, 0, 34, 10, 1, 0, 28, 16, 1, 0, 22, 22, 1, 0, 16, 28,
            1, 0, 55, 15, 1, 0, 44, 26, 2, 0, 17, 18, 2, 0, 13, 22,
            1, 0, 80, 20, 2, 0, 32, 18, 2, 0, 24, 26, 4, 0, 9, 16,
            1, 0, 108, 26, 2, 0, 43, 24, 2, 2, 15, 18, 2, 2, 11, 22,
            2, 0, 68, 18, 4, 0, 27, 16, 4, 0, 19, 24, 4, 0, 15, 28,
            2, 0, 78, 20, 4, 0, 31, 18, 2, 4, 14, 18, 4, 1, 13, 26,
            2, 0, 97, 24, 2, 2, 38, 22, 4, 2, 18, 22, 4, 2, 14, 26,
            2, 0, 116, 30, 3, 2, 36, 22, 4, 4, 16, 20, 4, 4, 12, 24,
            2, 2, 68, 18, 4, 1, 43, 26, 6, 2, 19, 24, 6, 2, 15, 28,
            4, 0, 81, 20, 1, 4, 50, 30, 4, 4, 22, 28, 3, 8, 12, 24,
            2, 2, 92, 24, 6, 2, 36, 22, 4, 6, 20, 26, 7, 4, 14, 28,
            4, 0, 107, 26, 8, 1, 37, 22, 8, 4, 20, 24, 12, 4, 11, 22,
            3, 1, 115, 30, 4, 5, 40, 24, 11, 5, 16, 20, 11, 5, 12, 24,
            5, 1, 87, 22, 5, 5, 41, 24, 5, 7, 24, 30, 11, 7, 12, 24,
            5, 1, 98, 24, 7, 3, 45, 28, 15, 2, 19, 24, 3, 13, 15, 30,
            1, 5, 107, 28, 10, 1, 46, 28, 1, 15, 22, 28, 2, 17, 14, 28,
            5, 1, 120, 30, 9, 4, 43, 26, 17, 1, 22, 28, 2, 19, 14, 28,
            3, 4, 113, 28, 3, 11, 44, 26, 17, 4, 21, 26, 9, 16, 13, 26,
            3, 5, 107, 28, 3, 13, 41, 26, 15, 5, 24, 30, 15, 10, 15, 28,
            4, 4, 116, 28, 17, 0, 42, 26, 17, 6, 22, 28, 19, 6, 16, 30,
            2, 7, 111, 28, 17, 0, 46, 28, 7, 16, 24, 30, 34, 0, 13, 24,
            4, 5, 121, 30, 4, 14, 47, 28, 11, 14, 24, 30, 16, 14, 15, 30,
            6, 4, 117, 30, 6, 14, 45, 28, 11, 16, 24, 30, 30, 2, 16, 30,
            8, 4, 106, 26, 8, 13, 47, 28, 7, 22, 24, 30, 22, 13, 15, 30,
            10, 2, 114, 28, 19, 4, 46, 28, 28, 6, 22, 28, 33, 4, 16, 30,
            8, 4, 122, 30, 22, 3, 45, 28, 8, 26, 23, 30, 12, 28, 15, 30,
            3, 10, 117, 30, 3, 23, 45, 28, 4, 31, 24, 30, 11, 31, 15, 30,
            7, 7, 116, 30, 21, 7, 45, 28, 1, 37, 23, 30, 19, 26, 15, 30,
            5, 10, 115, 30, 19, 10, 47, 28, 15, 25, 24, 30, 23, 25, 15, 30,
            13, 3, 115, 30, 2, 29, 46, 28, 42, 1, 24, 30, 23, 28, 15, 30,
            17, 0, 115, 30, 10, 23, 46, 28, 10, 35, 24, 30, 19, 35, 15, 30,
            17, 1, 115, 30, 14, 21, 46, 28, 29, 19, 24, 30, 11, 46, 15, 30,
            13, 6, 115, 30, 14, 23, 46, 28, 44, 7, 24, 30, 59, 1, 16, 30,
            12, 7, 121, 30, 12, 26, 47, 28, 39, 14, 24, 30, 22, 41, 15, 30,
            6, 14, 121, 30, 6, 34, 47, 28, 46, 10, 24, 30, 2, 64, 15, 30,
            17, 4, 122, 30, 29, 14, 46, 28, 49, 10, 24, 30, 24, 46, 15, 30,
            4, 18, 122, 30, 13, 32, 46, 28, 48, 14, 24, 30, 42, 32, 15, 30,
            20, 4, 117, 30, 40, 7, 47, 28, 43, 22, 24, 30, 10, 67, 15, 30,
            19, 6, 118, 30, 18, 31, 47, 28, 34, 34, 24, 30, 20, 61, 15, 30
        ];

        // Galois field log table
        glog = [
            0xff, 0x00, 0x01, 0x19, 0x02, 0x32, 0x1a, 0xc6, 0x03, 0xdf, 0x33, 0xee, 0x1b, 0x68, 0xc7, 0x4b,
            0x04, 0x64, 0xe0, 0x0e, 0x34, 0x8d, 0xef, 0x81, 0x1c, 0xc1, 0x69, 0xf8, 0xc8, 0x08, 0x4c, 0x71,
            0x05, 0x8a, 0x65, 0x2f, 0xe1, 0x24, 0x0f, 0x21, 0x35, 0x93, 0x8e, 0xda, 0xf0, 0x12, 0x82, 0x45,
            0x1d, 0xb5, 0xc2, 0x7d, 0x6a, 0x27, 0xf9, 0xb9, 0xc9, 0x9a, 0x09, 0x78, 0x4d, 0xe4, 0x72, 0xa6,
            0x06, 0xbf, 0x8b, 0x62, 0x66, 0xdd, 0x30, 0xfd, 0xe2, 0x98, 0x25, 0xb3, 0x10, 0x91, 0x22, 0x88,
            0x36, 0xd0, 0x94, 0xce, 0x8f, 0x96, 0xdb, 0xbd, 0xf1, 0xd2, 0x13, 0x5c, 0x83, 0x38, 0x46, 0x40,
            0x1e, 0x42, 0xb6, 0xa3, 0xc3, 0x48, 0x7e, 0x6e, 0x6b, 0x3a, 0x28, 0x54, 0xfa, 0x85, 0xba, 0x3d,
            0xca, 0x5e, 0x9b, 0x9f, 0x0a, 0x15, 0x79, 0x2b, 0x4e, 0xd4, 0xe5, 0xac, 0x73, 0xf3, 0xa7, 0x57,
            0x07, 0x70, 0xc0, 0xf7, 0x8c, 0x80, 0x63, 0x0d, 0x67, 0x4a, 0xde, 0xed, 0x31, 0xc5, 0xfe, 0x18,
            0xe3, 0xa5, 0x99, 0x77, 0x26, 0xb8, 0xb4, 0x7c, 0x11, 0x44, 0x92, 0xd9, 0x23, 0x20, 0x89, 0x2e,
            0x37, 0x3f, 0xd1, 0x5b, 0x95, 0xbc, 0xcf, 0xcd, 0x90, 0x87, 0x97, 0xb2, 0xdc, 0xfc, 0xbe, 0x61,
            0xf2, 0x56, 0xd3, 0xab, 0x14, 0x2a, 0x5d, 0x9e, 0x84, 0x3c, 0x39, 0x53, 0x47, 0x6d, 0x41, 0xa2,
            0x1f, 0x2d, 0x43, 0xd8, 0xb7, 0x7b, 0xa4, 0x76, 0xc4, 0x17, 0x49, 0xec, 0x7f, 0x0c, 0x6f, 0xf6,
            0x6c, 0xa1, 0x3b, 0x52, 0x29, 0x9d, 0x55, 0xaa, 0xfb, 0x60, 0x86, 0xb1, 0xbb, 0xcc, 0x3e, 0x5a,
            0xcb, 0x59, 0x5f, 0xb0, 0x9c, 0xa9, 0xa0, 0x51, 0x0b, 0xf5, 0x16, 0xeb, 0x7a, 0x75, 0x2c, 0xd7,
            0x4f, 0xae, 0xd5, 0xe9, 0xe6, 0xe7, 0xad, 0xe8, 0x74, 0xd6, 0xf4, 0xea, 0xa8, 0x50, 0x58, 0xaf
        ];

        // Galios field exponent table
        gexp = [
            0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x1d, 0x3a, 0x74, 0xe8, 0xcd, 0x87, 0x13, 0x26,
            0x4c, 0x98, 0x2d, 0x5a, 0xb4, 0x75, 0xea, 0xc9, 0x8f, 0x03, 0x06, 0x0c, 0x18, 0x30, 0x60, 0xc0,
            0x9d, 0x27, 0x4e, 0x9c, 0x25, 0x4a, 0x94, 0x35, 0x6a, 0xd4, 0xb5, 0x77, 0xee, 0xc1, 0x9f, 0x23,
            0x46, 0x8c, 0x05, 0x0a, 0x14, 0x28, 0x50, 0xa0, 0x5d, 0xba, 0x69, 0xd2, 0xb9, 0x6f, 0xde, 0xa1,
            0x5f, 0xbe, 0x61, 0xc2, 0x99, 0x2f, 0x5e, 0xbc, 0x65, 0xca, 0x89, 0x0f, 0x1e, 0x3c, 0x78, 0xf0,
            0xfd, 0xe7, 0xd3, 0xbb, 0x6b, 0xd6, 0xb1, 0x7f, 0xfe, 0xe1, 0xdf, 0xa3, 0x5b, 0xb6, 0x71, 0xe2,
            0xd9, 0xaf, 0x43, 0x86, 0x11, 0x22, 0x44, 0x88, 0x0d, 0x1a, 0x34, 0x68, 0xd0, 0xbd, 0x67, 0xce,
            0x81, 0x1f, 0x3e, 0x7c, 0xf8, 0xed, 0xc7, 0x93, 0x3b, 0x76, 0xec, 0xc5, 0x97, 0x33, 0x66, 0xcc,
            0x85, 0x17, 0x2e, 0x5c, 0xb8, 0x6d, 0xda, 0xa9, 0x4f, 0x9e, 0x21, 0x42, 0x84, 0x15, 0x2a, 0x54,
            0xa8, 0x4d, 0x9a, 0x29, 0x52, 0xa4, 0x55, 0xaa, 0x49, 0x92, 0x39, 0x72, 0xe4, 0xd5, 0xb7, 0x73,
            0xe6, 0xd1, 0xbf, 0x63, 0xc6, 0x91, 0x3f, 0x7e, 0xfc, 0xe5, 0xd7, 0xb3, 0x7b, 0xf6, 0xf1, 0xff,
            0xe3, 0xdb, 0xab, 0x4b, 0x96, 0x31, 0x62, 0xc4, 0x95, 0x37, 0x6e, 0xdc, 0xa5, 0x57, 0xae, 0x41,
            0x82, 0x19, 0x32, 0x64, 0xc8, 0x8d, 0x07, 0x0e, 0x1c, 0x38, 0x70, 0xe0, 0xdd, 0xa7, 0x53, 0xa6,
            0x51, 0xa2, 0x59, 0xb2, 0x79, 0xf2, 0xf9, 0xef, 0xc3, 0x9b, 0x2b, 0x56, 0xac, 0x45, 0x8a, 0x09,
            0x12, 0x24, 0x48, 0x90, 0x3d, 0x7a, 0xf4, 0xf5, 0xf7, 0xf3, 0xfb, 0xeb, 0xcb, 0x8b, 0x0b, 0x16,
            0x2c, 0x58, 0xb0, 0x7d, 0xfa, 0xe9, 0xcf, 0x83, 0x1b, 0x36, 0x6c, 0xd8, 0xad, 0x47, 0x8e, 0x00
        ];

        // Working buffers:
        // data input and ecc append, image working buffer, fixed part of image, run lengths for badness
        var strinbuf = [], eccbuf = [], qrframe = [], framask = [], rlens = [];
        // Control values - width is based on version, last 4 are from table.
        var version, width, neccblk1, neccblk2, datablkw, eccblkwid;
        var ecclevel = 1;
        // set bit to indicate cell in qrframe is immutable.  symmetric around diagonal
        function setmask(x, y) {
            var bt;
            if (x > y) {
                bt = x;
                x = y;
                y = bt;
            }
            // y*y = 1+3+5...
            bt = y;
            bt *= y;
            bt += y;
            bt >>= 1;
            bt += x;
            framask[bt] = 1;
        }

        // enter alignment pattern - black to qrframe, white to mask (later black frame merged to mask)
        function putalign(x, y) {
            var j;

            qrframe[x + width * y] = 1;
            for (j = -2; j < 2; j++) {
                qrframe[(x + j) + width * (y - 2)] = 1;
                qrframe[(x - 2) + width * (y + j + 1)] = 1;
                qrframe[(x + 2) + width * (y + j)] = 1;
                qrframe[(x + j + 1) + width * (y + 2)] = 1;
            }
            for (j = 0; j < 2; j++) {
                setmask(x - 1, y + j);
                setmask(x + 1, y - j);
                setmask(x - j, y - 1);
                setmask(x + j, y + 1);
            }
        }

        //========================================================================
        // Reed Solomon error correction
        // exponentiation mod N
        function modnn(x) {
            while (x >= 255) {
                x -= 255;
                x = (x >> 8) + (x & 255);
            }
            return x;
        }

        var genpoly = [];

        // Calculate and append ECC data to data block.  Block is in strinbuf, indexes to buffers given.
        function appendrs(data, dlen, ecbuf, eclen) {
            var i, j, fb;

            for (i = 0; i < eclen; i++)
                strinbuf[ecbuf + i] = 0;
            for (i = 0; i < dlen; i++) {
                fb = glog[strinbuf[data + i] ^ strinbuf[ecbuf]];
                if (fb != 255)     /* fb term is non-zero */
                    for (j = 1; j < eclen; j++)
                        strinbuf[ecbuf + j - 1] = strinbuf[ecbuf + j] ^ gexp[modnn(fb + genpoly[eclen - j])];
                else
                    for (j = ecbuf; j < ecbuf + eclen; j++)
                        strinbuf[j] = strinbuf[j + 1];
                strinbuf[ecbuf + eclen - 1] = fb == 255 ? 0 : gexp[modnn(fb + genpoly[0])];
            }
        }

        //========================================================================
        // Frame data insert following the path rules

        // check mask - since symmetrical use half.
        function ismasked(x, y) {
            var bt;
            if (x > y) {
                bt = x;
                x = y;
                y = bt;
            }
            bt = y;
            bt += y * y;
            bt >>= 1;
            bt += x;
            return framask[bt];
        }

        //========================================================================
        //  Apply the selected mask out of the 8.
        function applymask(m) {
            var x, y, r3x, r3y;

            switch (m) {
                case 0:
                    for (y = 0; y < width; y++)
                        for (x = 0; x < width; x++)
                            if (!((x + y) & 1) && !ismasked(x, y))
                                qrframe[x + y * width] ^= 1;
                    break;
                case 1:
                    for (y = 0; y < width; y++)
                        for (x = 0; x < width; x++)
                            if (!(y & 1) && !ismasked(x, y))
                                qrframe[x + y * width] ^= 1;
                    break;
                case 2:
                    for (y = 0; y < width; y++)
                        for (r3x = 0, x = 0; x < width; x++, r3x++) {
                            if (r3x == 3)
                                r3x = 0;
                            if (!r3x && !ismasked(x, y))
                                qrframe[x + y * width] ^= 1;
                        }
                    break;
                case 3:
                    for (r3y = 0, y = 0; y < width; y++, r3y++) {
                        if (r3y == 3)
                            r3y = 0;
                        for (r3x = r3y, x = 0; x < width; x++, r3x++) {
                            if (r3x == 3)
                                r3x = 0;
                            if (!r3x && !ismasked(x, y))
                                qrframe[x + y * width] ^= 1;
                        }
                    }
                    break;
                case 4:
                    for (y = 0; y < width; y++)
                        for (r3x = 0, r3y = ((y >> 1) & 1), x = 0; x < width; x++, r3x++) {
                            if (r3x == 3) {
                                r3x = 0;
                                r3y = !r3y;
                            }
                            if (!r3y && !ismasked(x, y))
                                qrframe[x + y * width] ^= 1;
                        }
                    break;
                case 5:
                    for (r3y = 0, y = 0; y < width; y++, r3y++) {
                        if (r3y == 3)
                            r3y = 0;
                        for (r3x = 0, x = 0; x < width; x++, r3x++) {
                            if (r3x == 3)
                                r3x = 0;
                            if (!((x & y & 1) + !(!r3x | !r3y)) && !ismasked(x, y))
                                qrframe[x + y * width] ^= 1;
                        }
                    }
                    break;
                case 6:
                    for (r3y = 0, y = 0; y < width; y++, r3y++) {
                        if (r3y == 3)
                            r3y = 0;
                        for (r3x = 0, x = 0; x < width; x++, r3x++) {
                            if (r3x == 3)
                                r3x = 0;
                            if (!(((x & y & 1) + (r3x && (r3x == r3y))) & 1) && !ismasked(x, y))
                                qrframe[x + y * width] ^= 1;
                        }
                    }
                    break;
                case 7:
                    for (r3y = 0, y = 0; y < width; y++, r3y++) {
                        if (r3y == 3)
                            r3y = 0;
                        for (r3x = 0, x = 0; x < width; x++, r3x++) {
                            if (r3x == 3)
                                r3x = 0;
                            if (!(((r3x && (r3x == r3y)) + ((x + y) & 1)) & 1) && !ismasked(x, y))
                                qrframe[x + y * width] ^= 1;
                        }
                    }
                    break;
            }
            return;
        }

        // Badness coefficients.
        var N1 = 3, N2 = 3, N3 = 40, N4 = 10;

        // Using the table of the length of each run, calculate the amount of bad image
        // - long runs or those that look like finders; called twice, once each for X and Y
        function badruns(length) {
            var i;
            var runsbad = 0;
            for (i = 0; i <= length; i++)
                if (rlens[i] >= 5)
                    runsbad += N1 + rlens[i] - 5;
            // BwBBBwB as in finder
            for (i = 3; i < length - 1; i += 2)
                if (rlens[i - 2] == rlens[i + 2]
                    && rlens[i + 2] == rlens[i - 1]
                    && rlens[i - 1] == rlens[i + 1]
                    && rlens[i - 1] * 3 == rlens[i]
                    // white around the black pattern? Not part of spec
                    && (rlens[i - 3] == 0 // beginning
                        || i + 3 > length  // end
                        || rlens[i - 3] * 3 >= rlens[i] * 4 || rlens[i + 3] * 3 >= rlens[i] * 4)
                )
                    runsbad += N3;
            return runsbad;
        }

        // Calculate how bad the masked image is - blocks, imbalance, runs, or finders.
        function badcheck() {
            var x, y, h, b, b1;
            var thisbad = 0;
            var bw = 0;

            // blocks of same color.
            for (y = 0; y < width - 1; y++)
                for (x = 0; x < width - 1; x++)
                    if ((qrframe[x + width * y] && qrframe[(x + 1) + width * y]
                        && qrframe[x + width * (y + 1)] && qrframe[(x + 1) + width * (y + 1)]) // all black
                        || !(qrframe[x + width * y] || qrframe[(x + 1) + width * y]
                            || qrframe[x + width * (y + 1)] || qrframe[(x + 1) + width * (y + 1)])) // all white
                        thisbad += N2;

            // X runs
            for (y = 0; y < width; y++) {
                rlens[0] = 0;
                for (h = b = x = 0; x < width; x++) {
                    if ((b1 = qrframe[x + width * y]) == b)
                        rlens[h]++;
                    else
                        rlens[++h] = 1;
                    b = b1;
                    bw += b ? 1 : -1;
                }
                thisbad += badruns(h);
            }

            // black/white imbalance
            if (bw < 0)
                bw = -bw;

            var big = bw;
            count = 0;
            big += big << 2;
            big <<= 1;
            while (big > width * width)
                big -= width * width, count++;
            thisbad += count * N4;

            // Y runs
            for (x = 0; x < width; x++) {
                rlens[0] = 0;
                for (h = b = y = 0; y < width; y++) {
                    if ((b1 = qrframe[x + width * y]) == b)
                        rlens[h]++;
                    else
                        rlens[++h] = 1;
                    b = b1;
                }
                thisbad += badruns(h);
            }
            return thisbad;
        }

        function genframe(instring) {
            var x, y, k, t, v, i, j, m;

            // find the smallest version that fits the string
            t = instring.length;
            version = 0;
            do {
                version++;
                k = (ecclevel - 1) * 4 + (version - 1) * 16;
                neccblk1 = eccblocks[k++];
                neccblk2 = eccblocks[k++];
                datablkw = eccblocks[k++];
                eccblkwid = eccblocks[k];
                k = datablkw * (neccblk1 + neccblk2) + neccblk2 - 3 + (version <= 9);
                if (t <= k)
                    break;
            } while (version < 40);

            // FIXME - insure that it fits insted of being truncated
            width = 17 + 4 * version;

            // allocate, clear and setup data structures
            v = datablkw + (datablkw + eccblkwid) * (neccblk1 + neccblk2) + neccblk2;
            for (t = 0; t < v; t++)
                eccbuf[t] = 0;
            strinbuf = instring.slice(0);

            for (t = 0; t < width * width; t++)
                qrframe[t] = 0;

            for (t = 0; t < (width * (width + 1) + 1) / 2; t++)
                framask[t] = 0;

            // insert finders - black to frame, white to mask
            for (t = 0; t < 3; t++) {
                k = 0;
                y = 0;
                if (t == 1)
                    k = (width - 7);
                if (t == 2)
                    y = (width - 7);
                qrframe[(y + 3) + width * (k + 3)] = 1;
                for (x = 0; x < 6; x++) {
                    qrframe[(y + x) + width * k] = 1;
                    qrframe[y + width * (k + x + 1)] = 1;
                    qrframe[(y + 6) + width * (k + x)] = 1;
                    qrframe[(y + x + 1) + width * (k + 6)] = 1;
                }
                for (x = 1; x < 5; x++) {
                    setmask(y + x, k + 1);
                    setmask(y + 1, k + x + 1);
                    setmask(y + 5, k + x);
                    setmask(y + x + 1, k + 5);
                }
                for (x = 2; x < 4; x++) {
                    qrframe[(y + x) + width * (k + 2)] = 1;
                    qrframe[(y + 2) + width * (k + x + 1)] = 1;
                    qrframe[(y + 4) + width * (k + x)] = 1;
                    qrframe[(y + x + 1) + width * (k + 4)] = 1;
                }
            }

            // alignment blocks
            if (version > 1) {
                t = adelta[version];
                y = width - 7;
                for (; ;) {
                    x = width - 7;
                    while (x > t - 3) {
                        putalign(x, y);
                        if (x < t)
                            break;
                        x -= t;
                    }
                    if (y <= t + 9)
                        break;
                    y -= t;
                    putalign(6, y);
                    putalign(y, 6);
                }
            }

            // single black
            qrframe[8 + width * (width - 8)] = 1;

            // timing gap - mask only
            for (y = 0; y < 7; y++) {
                setmask(7, y);
                setmask(width - 8, y);
                setmask(7, y + width - 7);
            }
            for (x = 0; x < 8; x++) {
                setmask(x, 7);
                setmask(x + width - 8, 7);
                setmask(x, width - 8);
            }

            // reserve mask-format area
            for (x = 0; x < 9; x++)
                setmask(x, 8);
            for (x = 0; x < 8; x++) {
                setmask(x + width - 8, 8);
                setmask(8, x);
            }
            for (y = 0; y < 7; y++)
                setmask(8, y + width - 7);

            // timing row/col
            for (x = 0; x < width - 14; x++)
                if (x & 1) {
                    setmask(8 + x, 6);
                    setmask(6, 8 + x);
                }
                else {
                    qrframe[(8 + x) + width * 6] = 1;
                    qrframe[6 + width * (8 + x)] = 1;
                }

            // version block
            if (version > 6) {
                t = vpat[version - 7];
                k = 17;
                for (x = 0; x < 6; x++)
                    for (y = 0; y < 3; y++, k--)
                        if (1 & (k > 11 ? version >> (k - 12) : t >> k)) {
                            qrframe[(5 - x) + width * (2 - y + width - 11)] = 1;
                            qrframe[(2 - y + width - 11) + width * (5 - x)] = 1;
                        }
                        else {
                            setmask(5 - x, 2 - y + width - 11);
                            setmask(2 - y + width - 11, 5 - x);
                        }
            }

            // sync mask bits - only set above for white spaces, so add in black bits
            for (y = 0; y < width; y++)
                for (x = 0; x <= y; x++)
                    if (qrframe[x + width * y])
                        setmask(x, y);

            // convert string to bitstream
            // 8 bit data to QR-coded 8 bit data (numeric or alphanum, or kanji not supported)
            v = strinbuf.length;

            // string to array
            for (i = 0; i < v; i++)
                eccbuf[i] = strinbuf.charCodeAt(i);
            strinbuf = eccbuf.slice(0);

            // calculate max string length
            x = datablkw * (neccblk1 + neccblk2) + neccblk2;
            if (v >= x - 2) {
                v = x - 2;
                if (version > 9)
                    v--;
            }

            // shift and repack to insert length prefix
            i = v;
            if (version > 9) {
                strinbuf[i + 2] = 0;
                strinbuf[i + 3] = 0;
                while (i--) {
                    t = strinbuf[i];
                    strinbuf[i + 3] |= 255 & (t << 4);
                    strinbuf[i + 2] = t >> 4;
                }
                strinbuf[2] |= 255 & (v << 4);
                strinbuf[1] = v >> 4;
                strinbuf[0] = 0x40 | (v >> 12);
            }
            else {
                strinbuf[i + 1] = 0;
                strinbuf[i + 2] = 0;
                while (i--) {
                    t = strinbuf[i];
                    strinbuf[i + 2] |= 255 & (t << 4);
                    strinbuf[i + 1] = t >> 4;
                }
                strinbuf[1] |= 255 & (v << 4);
                strinbuf[0] = 0x40 | (v >> 4);
            }
            // fill to end with pad pattern
            i = v + 3 - (version < 10);
            while (i < x) {
                strinbuf[i++] = 0xec;
                // buffer has room    if (i == x)      break;
                strinbuf[i++] = 0x11;
            }

            // calculate and append ECC

            // calculate generator polynomial
            genpoly[0] = 1;
            for (i = 0; i < eccblkwid; i++) {
                genpoly[i + 1] = 1;
                for (j = i; j > 0; j--)
                    genpoly[j] = genpoly[j]
                        ? genpoly[j - 1] ^ gexp[modnn(glog[genpoly[j]] + i)] : genpoly[j - 1];
                genpoly[0] = gexp[modnn(glog[genpoly[0]] + i)];
            }
            for (i = 0; i <= eccblkwid; i++)
                genpoly[i] = glog[genpoly[i]]; // use logs for genpoly[] to save calc step

            // append ecc to data buffer
            k = x;
            y = 0;
            for (i = 0; i < neccblk1; i++) {
                appendrs(y, datablkw, k, eccblkwid);
                y += datablkw;
                k += eccblkwid;
            }
            for (i = 0; i < neccblk2; i++) {
                appendrs(y, datablkw + 1, k, eccblkwid);
                y += datablkw + 1;
                k += eccblkwid;
            }
            // interleave blocks
            y = 0;
            for (i = 0; i < datablkw; i++) {
                for (j = 0; j < neccblk1; j++)
                    eccbuf[y++] = strinbuf[i + j * datablkw];
                for (j = 0; j < neccblk2; j++)
                    eccbuf[y++] = strinbuf[(neccblk1 * datablkw) + i + (j * (datablkw + 1))];
            }
            for (j = 0; j < neccblk2; j++)
                eccbuf[y++] = strinbuf[(neccblk1 * datablkw) + i + (j * (datablkw + 1))];
            for (i = 0; i < eccblkwid; i++)
                for (j = 0; j < neccblk1 + neccblk2; j++)
                    eccbuf[y++] = strinbuf[x + i + j * eccblkwid];
            strinbuf = eccbuf;

            // pack bits into frame avoiding masked area.
            x = y = width - 1;
            k = v = 1;         // up, minus
            /* inteleaved data and ecc codes */
            m = (datablkw + eccblkwid) * (neccblk1 + neccblk2) + neccblk2;
            for (i = 0; i < m; i++) {
                t = strinbuf[i];
                for (j = 0; j < 8; j++, t <<= 1) {
                    if (0x80 & t)
                        qrframe[x + width * y] = 1;
                    do {        // find next fill position
                        if (v)
                            x--;
                        else {
                            x++;
                            if (k) {
                                if (y != 0)
                                    y--;
                                else {
                                    x -= 2;
                                    k = !k;
                                    if (x == 6) {
                                        x--;
                                        y = 9;
                                    }
                                }
                            }
                            else {
                                if (y != width - 1)
                                    y++;
                                else {
                                    x -= 2;
                                    k = !k;
                                    if (x == 6) {
                                        x--;
                                        y -= 8;
                                    }
                                }
                            }
                        }
                        v = !v;
                    } while (ismasked(x, y));
                }
            }

            // save pre-mask copy of frame
            strinbuf = qrframe.slice(0);
            t = 0;           // best
            y = 30000;         // demerit
            // for instead of while since in original arduino code
            // if an early mask was "good enough" it wouldn't try for a better one
            // since they get more complex and take longer.
            for (k = 0; k < 8; k++) {
                applymask(k);      // returns black-white imbalance
                x = badcheck();
                if (x < y) { // current mask better than previous best?
                    y = x;
                    t = k;
                }
                if (t == 7)
                    break;       // don't increment i to a void redoing mask
                qrframe = strinbuf.slice(0); // reset for next pass
            }
            if (t != k)         // redo best mask - none good enough, last wasn't t
                applymask(t);

            // add in final mask/ecclevel bytes
            y = fmtword[t + ((ecclevel - 1) << 3)];
            // low byte
            for (k = 0; k < 8; k++, y >>= 1)
                if (y & 1) {
                    qrframe[(width - 1 - k) + width * 8] = 1;
                    if (k < 6)
                        qrframe[8 + width * k] = 1;
                    else
                        qrframe[8 + width * (k + 1)] = 1;
                }
            // high byte
            for (k = 0; k < 7; k++, y >>= 1)
                if (y & 1) {
                    qrframe[8 + width * (width - 7 + k)] = 1;
                    if (k)
                        qrframe[(6 - k) + width * 8] = 1;
                    else
                        qrframe[7 + width * 8] = 1;
                }

            // return image
            return qrframe;
        }

        var wd, ht, qrc;
        function setupqr() {
            //    window.scrollTo(0,1)
            wd = window.innerWidth / 2;
            ht = window.innerHeight / 2;
            mp = document.getElementById("mapcanv");
            qrd = document.getElementById("qrdiv");
            if (qrd == null) {
                return;
            }

            qrd.style.width = wd + "px";
            qrd.style.height = ht + "px";

            wd -= 4;
            ht -= 80;

            var elem = document.getElementById('qrcanv');
            qrc = elem.getContext('2d');
            qrc.canvas.width = wd;
            qrc.canvas.height = ht;
            qrc.fillStyle = '#eee';
            qrc.fillRect(0, 0, wd, ht);

        }

        function doqr(EEC, qrinput) {
            if (qrd == null) {
                return;
            }
            d = document;
            ecclevel = EEC; // 1-4
            qf = genframe(qrinput);
            qrc.lineWidth = 1;

            var i, j;
            px = wd;
            if (ht < wd)
                px = ht;
            px /= width + 10;
            px = Math.round(px - 0.5);
            qrc.clearRect(0, 0, wd, ht);
            qrc.fillStyle = '#fff';
            qrc.fillRect(0, 0, px * (width + 8), px * (width + 8));
            qrc.fillStyle = '#000';
            for (i = 0; i < width; i++)
                for (j = 0; j < width; j++)
                    if (qf[j * width + i])
                        qrc.fillRect(px * (4 + i), px * (4 + j), px, px)
        }
    </script>

    <!-- Script with UTILITY functions-->
    <script>
        var isDebug = location.port == 44364 || location.pathname.indexOf("/ClientHtml/") != -1 ? true : false;
        var beepBase64 = "//uQRAAAAWMSLwUIYAAsYkXgoQwAEaYLWfkWgAI0wWs/ItAAAGDgYtAgAyN+QWaAAihwMWm4G8QQRDiMcCBcH3Cc+CDv/7xA4Tvh9Rz/y8QADBwMWgQAZG/ILNAARQ4GLTcDeIIIhxGOBAuD7hOfBB3/94gcJ3w+o5/5eIAIAAAVwWgQAVQ2ORaIQwEMAJiDg95G4nQL7mQVWI6GwRcfsZAcsKkJvxgxEjzFUgfHoSQ9Qq7KNwqHwuB13MA4a1q/DmBrHgPcmjiGoh//EwC5nGPEmS4RcfkVKOhJf+WOgoxJclFz3kgn//dBA+ya1GhurNn8zb//9NNutNuhz31f////9vt///z+IdAEAAAK4LQIAKobHItEIYCGAExBwe8jcToF9zIKrEdDYIuP2MgOWFSE34wYiR5iqQPj0JIeoVdlG4VD4XA67mAcNa1fhzA1jwHuTRxDUQ//iYBczjHiTJcIuPyKlHQkv/LHQUYkuSi57yQT//uggfZNajQ3Vmz+Zt//+mm3Wm3Q576v////+32///5/EOgAAADVghQAAAAA//uQZAUAB1WI0PZugAAAAAoQwAAAEk3nRd2qAAAAACiDgAAAAAAABCqEEQRLCgwpBGMlJkIz8jKhGvj4k6jzRnqasNKIeoh5gI7BJaC1A1AoNBjJgbyApVS4IDlZgDU5WUAxEKDNmmALHzZp0Fkz1FMTmGFl1FMEyodIavcCAUHDWrKAIA4aa2oCgILEBupZgHvAhEBcZ6joQBxS76AgccrFlczBvKLC0QI2cBoCFvfTDAo7eoOQInqDPBtvrDEZBNYN5xwNwxQRfw8ZQ5wQVLvO8OYU+mHvFLlDh05Mdg7BT6YrRPpCBznMB2r//xKJjyyOh+cImr2/4doscwD6neZjuZR4AgAABYAAAABy1xcdQtxYBYYZdifkUDgzzXaXn98Z0oi9ILU5mBjFANmRwlVJ3/6jYDAmxaiDG3/6xjQQCCKkRb/6kg/wW+kSJ5//rLobkLSiKmqP/0ikJuDaSaSf/6JiLYLEYnW/+kXg1WRVJL/9EmQ1YZIsv/6Qzwy5qk7/+tEU0nkls3/zIUMPKNX/6yZLf+kFgAfgGyLFAUwY//uQZAUABcd5UiNPVXAAAApAAAAAE0VZQKw9ISAAACgAAAAAVQIygIElVrFkBS+Jhi+EAuu+lKAkYUEIsmEAEoMeDmCETMvfSHTGkF5RWH7kz/ESHWPAq/kcCRhqBtMdokPdM7vil7RG98A2sc7zO6ZvTdM7pmOUAZTnJW+NXxqmd41dqJ6mLTXxrPpnV8avaIf5SvL7pndPvPpndJR9Kuu8fePvuiuhorgWjp7Mf/PRjxcFCPDkW31srioCExivv9lcwKEaHsf/7ow2Fl1T/9RkXgEhYElAoCLFtMArxwivDJJ+bR1HTKJdlEoTELCIqgEwVGSQ+hIm0NbK8WXcTEI0UPoa2NbG4y2K00JEWbZavJXkYaqo9CRHS55FcZTjKEk3NKoCYUnSQ0rWxrZbFKbKIhOKPZe1cJKzZSaQrIyULHDZmV5K4xySsDRKWOruanGtjLJXFEmwaIbDLX0hIPBUQPVFVkQkDoUNfSoDgQGKPekoxeGzA4DUvnn4bxzcZrtJyipKfPNy5w+9lnXwgqsiyHNeSVpemw4bWb9psYeq//uQZBoABQt4yMVxYAIAAAkQoAAAHvYpL5m6AAgAACXDAAAAD59jblTirQe9upFsmZbpMudy7Lz1X1DYsxOOSWpfPqNX2WqktK0DMvuGwlbNj44TleLPQ+Gsfb+GOWOKJoIrWb3cIMeeON6lz2umTqMXV8Mj30yWPpjoSa9ujK8SyeJP5y5mOW1D6hvLepeveEAEDo0mgCRClOEgANv3B9a6fikgUSu/DmAMATrGx7nng5p5iimPNZsfQLYB2sDLIkzRKZOHGAaUyDcpFBSLG9MCQALgAIgQs2YunOszLSAyQYPVC2YdGGeHD2dTdJk1pAHGAWDjnkcLKFymS3RQZTInzySoBwMG0QueC3gMsCEYxUqlrcxK6k1LQQcsmyYeQPdC2YfuGPASCBkcVMQQqpVJshui1tkXQJQV0OXGAZMXSOEEBRirXbVRQW7ugq7IM7rPWSZyDlM3IuNEkxzCOJ0ny2ThNkyRai1b6ev//3dzNGzNb//4uAvHT5sURcZCFcuKLhOFs8mLAAEAt4UWAAIABAAAAAB4qbHo0tIjVkUU//uQZAwABfSFz3ZqQAAAAAngwAAAE1HjMp2qAAAAACZDgAAAD5UkTE1UgZEUExqYynN1qZvqIOREEFmBcJQkwdxiFtw0qEOkGYfRDifBui9MQg4QAHAqWtAWHoCxu1Yf4VfWLPIM2mHDFsbQEVGwyqQoQcwnfHeIkNt9YnkiaS1oizycqJrx4KOQjahZxWbcZgztj2c49nKmkId44S71j0c8eV9yDK6uPRzx5X18eDvjvQ6yKo9ZSS6l//8elePK/Lf//IInrOF/FvDoADYAGBMGb7FtErm5MXMlmPAJQVgWta7Zx2go+8xJ0UiCb8LHHdftWyLJE0QIAIsI+UbXu67dZMjmgDGCGl1H+vpF4NSDckSIkk7Vd+sxEhBQMRU8j/12UIRhzSaUdQ+rQU5kGeFxm+hb1oh6pWWmv3uvmReDl0UnvtapVaIzo1jZbf/pD6ElLqSX+rUmOQNpJFa/r+sa4e/pBlAABoAAAAA3CUgShLdGIxsY7AUABPRrgCABdDuQ5GC7DqPQCgbbJUAoRSUj+NIEig0YfyWUho1VBBBA//uQZB4ABZx5zfMakeAAAAmwAAAAF5F3P0w9GtAAACfAAAAAwLhMDmAYWMgVEG1U0FIGCBgXBXAtfMH10000EEEEEECUBYln03TTTdNBDZopopYvrTTdNa325mImNg3TTPV9q3pmY0xoO6bv3r00y+IDGid/9aaaZTGMuj9mpu9Mpio1dXrr5HERTZSmqU36A3CumzN/9Robv/Xx4v9ijkSRSNLQhAWumap82WRSBUqXStV/YcS+XVLnSS+WLDroqArFkMEsAS+eWmrUzrO0oEmE40RlMZ5+ODIkAyKAGUwZ3mVKmcamcJnMW26MRPgUw6j+LkhyHGVGYjSUUKNpuJUQoOIAyDvEyG8S5yfK6dhZc0Tx1KI/gviKL6qvvFs1+bWtaz58uUNnryq6kt5RzOCkPWlVqVX2a/EEBUdU1KrXLf40GoiiFXK///qpoiDXrOgqDR38JB0bw7SoL+ZB9o1RCkQjQ2CBYZKd/+VJxZRRZlqSkKiws0WFxUyCwsKiMy7hUVFhIaCrNQsKkTIsLivwKKigsj8XYlwt/WKi2N4d//uQRCSAAjURNIHpMZBGYiaQPSYyAAABLAAAAAAAACWAAAAApUF/Mg+0aohSIRobBAsMlO//Kk4soosy1JSFRYWaLC4qZBYWFRGZdwqKiwkNBVmoWFSJkWFxX4FFRQWR+LsS4W/rFRb/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////VEFHAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAU291bmRib3kuZGUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAMjAwNGh0dHA6Ly93d3cuc291bmRib3kuZGUAAAAAAAAAACU=";
        var beepSound = new Audio("data:audio/wav;base64," + beepBase64);
        function beep() {
            try {
                beepSound.play();
            }
            catch (err) {
            }
        }

        async function resolveDNS(url) {
            if (url.indexOf("://") == -1) {
                url = "http://" + url;
            }
            let builder = new URL(url);
            var host = builder.host;
            let provider = "https://dns.google/resolve?name=" + host
            let response = await fetch(provider);
            let json = await response.json();
            return json;
        }

        function alertBox(text) {
            document.getElementById("alertBox").innerText = text;
            beep();
        }

        function dateToTicks(dateObject) {
            return ((dateObject.getTime() * 10000) + 621355968000000000);
        }

        function ticksToDate(ticks) {
            let jsTicks = (ticks - 621355968000000000) / 10000;
            return new Date(jsTicks);
        }

        function resizeImage(e, size) {
            return new Promise(resolve => {
                const img = document.createElement("img");
                img.onload = function (event) {
                    let canvas = document.createElement("canvas");
                    let ctx = canvas.getContext("2d");
                    ctx.drawImage(img, 0, 0);
                    let MAX_WIDTH = size;
                    let MAX_HEIGHT = size;
                    let width = img.width;
                    let height = img.height;
                    if (width > height) {
                        if (width > MAX_WIDTH) {
                            height *= MAX_WIDTH / width;
                            width = MAX_WIDTH;
                        }
                    } else {
                        if (height > MAX_HEIGHT) {
                            width *= MAX_HEIGHT / height;
                            height = MAX_HEIGHT;
                        }
                    }
                    canvas.width = width;
                    canvas.height = height;
                    let ctx2 = canvas.getContext("2d");
                    ctx2.drawImage(img, 0, 0, width, height);
                    let dataURL = canvas.toDataURL('image/jpeg', 0.5);
                    resolve(dataURL);
                }
                img.src = e.target.result;
            });
        }

        function bytesToSize(bytes) {
            var sizes = ['Bytes', 'KB', 'MB', 'GB', 'TB'];
            if (bytes == 0) return '0 Byte';
            var i = parseInt(Math.floor(Math.log(bytes) / Math.log(1024)));
            return Math.round(bytes / Math.pow(1024, i), 2) + ' ' + sizes[i];
        }

        function splitData(data) {
            let offset = 0;
            let datas = [];
            while (offset < data.byteLength) {
                let len = bufferToInt(data, offset);
                offset += 4;
                let part = data.slice(offset, offset + len);
                datas.push(part);
                offset += len;
            }
            return datas;
        }

        function sortCollectionElement(collectionElement, comparer) {
            let childNodes = collectionElement.childNodes;
            let itemsArr = [];
            for (let i = 0; i < childNodes.length; i++) {
                if (childNodes[i].nodeType == 1) { // get rid of the whitespace text nodes
                    itemsArr.push(childNodes[i]);
                }
            }
            itemsArr.sort(comparer);
            childNodes.innerHTML = '';
            itemsArr.forEach(element => {
                collectionElement.appendChild(element)
            });
        }

        function downloadArrayBuffer(fileName, bytes, isShare) {
            let extension = fileName.substring(fileName.lastIndexOf('.') + 1);
            extension = extension.toLowerCase();
            let type;
            switch (extension) {
                case "mp4":
                case "mpg":
                case "mpeg":
                case "mpe":
                    type = "video/mpeg";
                    break;
                case "mov":
                case "qt":
                case "movie":
                    type = "video/quicktime";
                    break;
                case "avi":
                    type = "video/x-msvideo";
                    break;
                case "mp3":
                    type = "audio/mpeg";
                    break;
                case "jpg":
                case "jpeg":
                    type = "image/jpeg";
                    break;
                case "png":
                    type = "image/png";
                    break;
                case "tif":
                    type = "image/tiff";
                    break;
                case "webp":
                    type = "image/webp";
                    break;
                case "ico":
                    type = "image/ico";
                    break;
                case "doc":
                case "docx":
                    type = "application/msword";
                    break;
                default:
                    type = "application/" + extension;
            }
            if (isShare) {
                var isShare = confirm("Share " + fileName + " ?");
            }
            if (isShare) {
                // NOTE: In the tested browser the share function does not work, it returns an error on permissions in performing the operation. So in fact you need to download and then share the file
                let file = new File([bytes], fileName, { type: type });
                let filesArray = [];
                filesArray.push(file)
                navigator.share({
                    files: filesArray,
                    title: 'Share file',
                    text: fileName,
                }).then(() => console.log('Share was successful.'))
                    .catch((error) => { alertBox(error); console.log('Sharing failed', error) });
            } else {
                let blob = new Blob([bytes], { type: type });
                var link = document.createElement('a');
                link.href = window.URL.createObjectURL(blob);
                link.download = fileName;
                link.click();
            }
        };

        async function NewSession(id) {
            if (id == undefined) {
                id = 0;
            }
            session = {
                id: id,
                entryPoint: null,
                clientId: null,
                publicKeyB64: null, // This key must be generated by the Javascript in the browser
                encryptionType: null, // Indicates the type of encryption that is set for communication, it can be aes or xorAB for if aes encryption is not supported
                deviceKey: null, // Is the aes-cbc key that was generated by the device and you need to encrypt any data sent to the device using this key!
                IV: null,
                QRkey: null,
                serverId: null,
            }
            await generateKeyRSA();
            while (session.clientId == null) {

            }
        }

        function SaveClient() {
            if (session != null && session.id != null) {
                let json = JSON.stringify(session);
                localStorage.setItem(session.id, json);
            }
        }

        async function LoadClient(id) {
            let json = localStorage.getItem(id);
            if (json != 'null') {
                session = JSON.parse(json);
                await entryPointToProxy(session.entryPoint);
                if (session.encryptionType = "aes") {
                    importSecretKey(base64ToBuffer(session.deviceKey)).then(
                        key => {
                            cryptoKey = key;
                            getDir("");
                        }
                    );
                } else {
                    getDir("");
                }
                return true;
            }
            return false;
        }

        // id = id of client to delete, if is undefined, then the id is the id of current session (if the user are logged in the cloud)
        // if you delete the current sesion (the id is the id of current session), then automatically start a new session
        function DeleteClient(id) {
            if (id == undefined && session != null && session.id != null) {
                id = session.id;
            }
            if (id != undefined) {
                localStorage.setItem(id, null);
            }
            if (session != null && session.id == id) {
                NewSession(id);
            }
        }

    </script>

    <!-- Script with basic functions of CONVERSION, CODING, ENCRYPTION -->
    <script>

        function enumToString(enumerator, value) {
            for (var k in enumerator) if (enumerator[k] == value) return k;
            return null;
        }

        function bufferToHex(buffer) {
            return [...new Uint8Array(buffer)]
                .map(x => x.toString(16).padStart(2, '0'))
                .join('');
        }

        function int64ToBuffer(long) {
            return numberToBuffer(long, 8);
        };

        function int32ToBuffer(int) {
            return numberToBuffer(int, 4);
        }

        function int16ToBuffer(short) {
            return numberToBuffer(short, 2);
        };

        function numberToBuffer(number, returnBytes) {
            var byteBuffer = new Uint8Array(returnBytes);
            for (var index = 0; index < byteBuffer.length; index++) {
                var byte = number & 0xff;
                byteBuffer[index] = byte;
                number = (number - byte) / 256;
            }
            return byteBuffer;
        }

        function bufferToInt(data, offset) {
            offset = offset != undefined ? offset : 0;
            let bytes = data.slice(offset, offset + 4);
            return new Int32Array(bytes)[0];
        }

        function bufferToUint(data, offset) {
            offset = offset != undefined ? offset : 0;
            let bytes = data.slice(offset, offset + 4);
            return new Uint32Array(bytes)[0];
        }

        function dataURLtoBase64(dataUrl) {
            let position = dataUrl.search(",");
            return dataUrl.substring(position + 1);
        }

        function base64ToBuffer(base64) {
            var binary_string = atob(base64);
            var len = binary_string.length;
            var bytes = new Uint8Array(len);
            for (var i = 0; i < len; i++) {
                bytes[i] = binary_string.charCodeAt(i);
            }
            return bytes.buffer;
        }

        //function bufferToBase64(buffer) {
        //    const exportedAsBase64 = window.btoa(buffer);
        //    return exportedAsBase64;
        //}

        function bufferToJwkBase64(buffer) {
            var binary = '';
            var bytes = new Uint8Array(buffer);
            var len = bytes.byteLength;
            for (var i = 0; i < len; i++) {
                binary += String.fromCharCode(bytes[i]);
            }
            var base64 = window.btoa(binary);
            var jwk_base64 = base64.replace(/\+/g, '-').replace(/\//g, '_').replace(/\=+$/, '');
            return jwk_base64;
        }

        function bufferToBase64(buffer) {
            const exportedAsString = bufferToStringBinary(buffer);
            return btoa(exportedAsString);
        }

        function stringToB64(text) { return btoa(text); } // text to base64

        function b64ToString(text) { return atob(text); } // text to base64

        function encodeUtf8(s) {
            return unescape(encodeURIComponent(s));
        }

        function decodeUtf8(s) {
            return decodeURIComponent(escape(s));
        }

        function decodeBase64Url(input) {
            // Replace non-url compatible chars with base64 standard chars
            input = input
                .replace(/-/g, '+')
                .replace(/_/g, '/');

            // Pad out with standard base64 required padding characters
            let pad = input.length % 4;
            if (pad) {
                if (pad === 1) {
                    throw new Error('InvalidLengthError: Input base64url string is the wrong length to determine padding');
                }
                input += new Array(5 - pad).join('=');
            }
            return input;
        }

        // Convert an Buffer into a string (UTF8 encoding)
        function bufferToString(buf) {
            var decoder = new TextDecoder("utf-8");
            return decoder.decode(buf);
        }

        //Convert an Buffer into a string from https://developers.google.com/web/updates/2012/06/How-to-convert-ArrayBuffer-to-and-from-String
        function bufferToStringBinary(buf) {
            const array = new Uint8Array(buf);
            let result = "";
            let offset = 0;
            while (offset < array.length) {
                let size = Math.min(8192, array.length - offset);
                result += String.fromCharCode.apply(null, array.slice(offset, offset + size));
                offset += size;
            }
            return result;
        }

        //Convert a string into an Buffer (UTF8 encoding)
        function stringToBuffer(str) {
            let encoder = new TextEncoder(); // always utf-8
            return encoder.encode(str).buffer;
        }

        async function hash256(buffer) {
            return crypto.subtle.digest('SHA-256', buffer);
        }

        async function hash512(buffer) {
            return crypto.subtle.digest('SHA-512', buffer);
        }

        async function exportCryptoKey(key) {
            let k = await window.crypto.subtle.exportKey(
                "jwk",
                key
            )
            session.publicKeyB64 = decodeBase64Url(k.n);
            let keyBin = base64ToBuffer(session.publicKeyB64);
            let digestHex = await hash256(keyBin);
            session.clientId = bufferToHex(digestHex.slice(0, 8));
            showQrCode();
        }

        // async function exportCryptoKey(key) {
        //     window.crypto.subtle.exportKey(
        //         "jwk",
        //         key
        //     ).then(k => {
        //         resolve("");
        //         session.publicKeyB64 = decodeBase64Url(k.n);
        //         let keyBin = base64ToBuffer(session.publicKeyB64);
        //         hash256(keyBin).then(digestHex => {
        //             session.clientId = bufferToHex(digestHex.slice(0, 8));
        //         });
        //         showQrCode();
        //     });
        // }

        function showQrCode() {
            //document.getElementById("qrCode").innerHTML = publicKeyB64
            if (!setupQr) {
                setupqr();
                setupQr = true;
            }
            doqr(1, session.publicKeyB64);
        }

        // Encryption documentation
        // https://developer.ibm.com/articles/secure-javascript-applications-with-web-crypto-api/

        //// The same encryption algorithm of the NBitcoin library in c# (PubKey.Encrypt)
        //function encryptNBitcoin(btcPublicKey, data) {
        //    return new Promise(resolve => {
        //        hash512(btcPublicKey).then(sharedKey => {
        //            let iv = sharedKey.slice(0, 16);
        //            let encryptionKey = sharedKey.slice(16, 32);
        //            let hashingKey = sharedKey.slice(32);
        //            crypto.subtle.importKey("raw", encryptionKey, "AES-CBC", false, ["encrypt", "decrypt"]).then(key_encoded => {

        //                window.crypto.subtle.encrypt(
        //                    {
        //                        name: "AES-CBC",
        //                        iv
        //                    },
        //                    key_encoded,
        //                    data
        //                ).then(cipherText => {
        //                    let encrypted = joinBuffers(stringToBuffer("BIE1"), btcPublicKey);
        //                    encrypted = joinBuffers(encrypted, cipherText);
        //                    HMACSHA256(hashingKey, encrypted).then(hashMAC => {
        //                        resolve(joinBuffers(encrypted, hashMAC));
        //                    });
        //                    // + BIE1 + pubKey + cipherText + hashMAC
        //                });
        //            });
        //        });
        //    });
        //}


        function fastHash256(arrayBuffer) {
            let bytes = new Uint8Array(arrayBuffer).buffer;
            let bl = bytes.byteLength;
            let newsize = Math.ceil(bl / 32) * 32;
            bytes = resizeBuffers(bytes, newsize);
            let data = new Int32Array(bytes);
            let p0 = 0b01010101_01010101_01010101_01010101;
            let p1 = 0b00110011_00110011_00110011_00110011;
            let p2 = 0b00100100_10010010_00100100_10010010;
            let p3 = 0b00011100_01110001_11000111_00011100;
            let p4 = p0 ^ -1;
            let p5 = p1 ^ -1;
            let p6 = p2 ^ -1;
            let p7 = p3 ^ -1;
            //x = (bl * 1103515245 + 12345) & 0x7fffffff;
            let x = bl ^ 0x55555555;
            x ^= x << (1 + bl % 30);
            x ^= 0x55555555;
            x ^= x >> (1 + bl % 29);
            for (let i = 0; i < data.length; i += 8) {
                let v0 = data[i];
                let v1 = data[i + 1];
                let v2 = data[i + 2];
                let v3 = data[i + 3];
                let v4 = data[i + 4];
                let v5 = data[i + 5];
                let v6 = data[i + 6];
                let v7 = data[i + 7];
                x ^= (v0 ^ v1 ^ v2 ^ v3 ^ v4 ^ v5 ^ v6 ^ v7);
                x ^= 0x55555555;
                x ^= x << (1 + x % 28);
                x ^= 0x55555555;
                x ^= x >> (1 + x % 29);
                x ^= 0x55555555;
                x ^= x << (1 + x % 30);
                p0 ^= v0 ^ x;
                p1 ^= v1 ^ x;
                p2 ^= v2 ^ x;
                p3 ^= v3 ^ x;
                p4 ^= v4 ^ x;
                p5 ^= v5 ^ x;
                p6 ^= v6 ^ x;
                p7 ^= v7 ^ x;
            }
            let result = new Int32Array(8);
            result[0] = p0;
            result[1] = p1;
            result[2] = p2;
            result[3] = p3;
            result[4] = p4;
            result[5] = p5;
            result[6] = p6;
            result[7] = p7;
            return result.buffer;
        }

        function encryptXorAB(key, data) {
            let tmpKey = new Uint8Array(key).slice().buffer;
            let dl = data.byteLength;
            let newsize = Math.ceil(dl / 4) * 4;
            let dt = new Uint32Array(resizeBuffers(data, newsize));
            return new Promise((resolve, reject) => {
                let k3 = key;
                let target = new Uint32Array(dt.length);
                if (tmpKey.byteLength < 4) {
                    tmpKey = resizeBuffers(tmpKey, 4);
                }
                let k = new Uint32Array(tmpKey);
                k[0] = k[0] ^ dl;
                tmpKey = k.buffer;
                for (let i = 0; i < dt.length; i++) {
                    var p = i % k.length;
                    if (p == 0) {
                        //  tmpKey = await hash512(tmpKey);
                        tmpKey = fastHash256(tmpKey)
                        k = new Uint32Array(tmpKey);
                    }
                    target[i] = dt[i] ^ k[p];
                }
                let result = target.buffer.slice(0, dl);
                resolve(result);
            });
        }

        function decryptXorAB(key, data) {
            return encryptXorAB(key, data);
        }

        function encryptData(key, data) {
            return new Promise(resolve => {
                hash256(key).then(sharedKey => {
                    let iv = sharedKey.slice(0, 16);
                    let encryptionKey = sharedKey.slice(16, 32);
                    crypto.subtle.importKey("raw", encryptionKey, "AES-CBC", false, ["encrypt", "decrypt"]).then(key_encoded => {
                        window.crypto.subtle.encrypt(
                            {
                                name: "AES-CBC",
                                iv
                            },
                            key_encoded,
                            data
                        ).then(cipherData => {
                            resolve(cipherData);
                        });
                    });
                });
            });
        }

        async function HMACSHA256(key, message) {
            k = key,
                m = message,
                c = await crypto.subtle.importKey('raw', k, { name: 'HMAC', hash: 'SHA-256' }, true, ['sign']),
                s = await crypto.subtle.sign('HMAC', c, m);
            [new Uint8Array(s)].map(b => b.toString(16).padStart(2, '0')).join('');
            return s;
        }

        // async function generateKeyRSA() {
        //    await window.crypto.subtle.generateKey(
        //         {
        //             name: "RSA-OAEP",
        //             modulusLength: 2048,
        //             publicExponent: new Uint8Array([1, 0, 1]),
        //             hash: "SHA-256",
        //         }, true, ["encrypt", "decrypt"]).then(keyPair => {
        //             privateKey = keyPair.privateKey;
        //             publicKey = keyPair.publicKey;
        //             exportCryptoKey(publicKey);
        //         });
        // }

        async function generateKeyRSA() {
            let keyPair = await window.crypto.subtle.generateKey(
                {
                    name: "RSA-OAEP",
                    modulusLength: 2048,
                    publicExponent: new Uint8Array([1, 0, 1]),
                    hash: "SHA-256",
                }, true, ["encrypt", "decrypt"]);
            privateKey = keyPair.privateKey;
            publicKey = keyPair.publicKey;
            await exportCryptoKey(publicKey);

            //     keyPair => {
            //     privateKey = keyPair.privateKey;
            //     publicKey = keyPair.publicKey;
            // };
        }


        // Encryption with asymmetric encryption algorithm. This function is used to decrypt data encrypted with the public key. The encryption key generated by the device is encrypted with the public key scanned with the QR code, sent to the browser which decrypts it and uses it for communication.
        function decryptRsa(ciphertext) {
            //https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/decrypt
            let blockSize = 256;
            let promises
            let i = 0;
            while (i < ciphertext.byteLength) {
                let chunk = ciphertext.slice(i, i + blockSize);
                let decryptedPromise = window.crypto.subtle.decrypt(
                    {
                        name: "RSA-OAEP"
                    },
                    privateKey,
                    chunk
                );
                if (promises == undefined) {
                    promises = [decryptedPromise];
                }
                else {
                    promises = promises.concat([decryptedPromise])
                }
                i += blockSize;
            };

            return Promise.all(promises).then(function (buffers) {
                let result;
                buffers.forEach(function (item) {
                    if (result == undefined) {
                        result = item;
                    } else {
                        result = joinBuffers(result, item);
                    }
                })
                return result;
            });
        }

        function encryptRsa(publicKey, data) {
            let blockSize = 190; // Larger blocks give errors
            let promises;
            let i = 0;
            while (i < data.byteLength) {
                let chunk = data.slice(i, i + blockSize);
                let promise = window.crypto.subtle.encrypt(
                    {
                        name: "RSA-OAEP"
                    },
                    publicKey,
                    chunk
                ).catch(function (err) {
                    console.log(err); debugger;
                });
                if (promises == undefined) {
                    promises = [promise];
                }
                else {
                    promises = promises.concat([promise])
                }
                i += blockSize;
            };

            return Promise.all(promises).then(function (buffers) {
                let result;
                buffers.forEach(function (item) {
                    if (result == undefined) {
                        result = item;
                    } else {
                        result = joinBuffers(result, item);
                    }
                })
                return result;
            });
        }

        function importRsaPublicKey(modulus, exponent) {
            if (modulus.byteLength != 2048 / 8) {
                debugger
                // NOTE: modulus with sizes different of 2048 give an error during decryption
                // Trying to make it work is just a waste of time!!
            }
            let n = bufferToJwkBase64(modulus);
            let e = bufferToJwkBase64(exponent);
            let jwk = {
                kty: 'RSA',
                n: n,
                e: e,
                alg: 'RSA-OAEP-256',
                ext: true
            };

            let algo = {
                name: 'RSA-OAEP',
                hash: { name: 'SHA-256' }
            };

            var importedKey = crypto.subtle.importKey('jwk', jwk, algo, true, ['encrypt']).catch(function (err) {
                console.log(err); debugger;
            });
            return importedKey;
        }

        // function encryptRsa(publicKey, data) {
        //     let blockSize = 190;
        //     let promises
        //     let i = 0;
        //     while (i < data.byteLength) {
        //         let chunk = data.slice(i, i + blockSize);
        //         let promise = window.crypto.subtle.encrypt(
        //             {
        //                 name: "RSASSA-PKCS1-v1_5"
        //             },
        //             publicKey,
        //             chunk
        //         ).catch(function (err) {
        //             console.log(err); debugger;
        //         });
        //         if (promises == undefined) {
        //             promises = [promise];
        //         }
        //         else {
        //             promises = promises.concat([promise])
        //         }
        //         i += blockSize;
        //     };

        //     return Promise.all(promises).then(function (buffers) {
        //         let result;
        //         buffers.forEach(function (item) {
        //             if (result == undefined) {
        //                 result = item;
        //             } else {
        //                 result = joinBuffers(result, item);
        //             }
        //         })
        //         return result;
        //     });
        // }

        // function importRsaPublicKey(modulus, exponent) {
        //     let n = bufferToJwkBase64(modulus);
        //     let e = bufferToJwkBase64(exponent);

        //     var importedKey = crypto.subtle.importKey(
        //         "jwk",
        //         {
        //             alg: "RS256",
        //             ext: true,
        //             key_ops: ["verify"],
        //             kty: "RSA",
        //             e: e,
        //             n: n,
        //         },
        //         {
        //             name: "RSASSA-PKCS1-v1_5",
        //             hash: "SHA-256",
        //         },
        //         false,
        //         ["verify"],
        //         ).catch(function (err) {
        //         console.log(err); debugger;
        //     });
        //     return importedKey;
        // }

        function joinBuffers(buffer1, buffer2) {
            let tmp = new Uint8Array(buffer1.byteLength + buffer2.byteLength);
            tmp.set(new Uint8Array(buffer1), 0);
            tmp.set(new Uint8Array(buffer2), buffer1.byteLength);
            return tmp.buffer;
        };

        function resizeBuffers(buffer, newsize) {
            let tmp = new Uint8Array(newsize);
            tmp.set(new Uint8Array(buffer), 0);
            return tmp.buffer;
        };

        //function encryptBigDataForTheDevice(data) {
        //    return new Promise((resolve, reject) => {
        //        const chunkSize = 10240;
        //        let result;
        //        let p = 0;
        //        function encryptBlock() {
        //            let chunk = data.slice(p, p + chunkSize);
        //            encryptDataForTheDevice(chunk).then(encrypted => {

        //                let a = new Uint8Array(encrypted);
        //                console.info(a[0]);

        //                let len = int16ToBuffer(encrypted.byteLength);
        //                let block = joinBuffers(len, encrypted);
        //                if (result == undefined) {
        //                    result = block;
        //                } else {
        //                    result = joinBuffers(result, block);
        //                }
        //                p += chunkSize;
        //                if (p >= data.byteLength) {
        //                    resolve(result);;
        //                } else {
        //                    encryptBlock();
        //                }

        //            });
        //        }
        //        encryptBlock();
        //    });
        //}

        function encryptDataForTheDevice(data) {
            // Data greater than about 12k gives an error in decryption. To send larger data it is recommended to break packets with encryptBigDataForTheDevice()
            if (session.encryptionType == "xorAB") {
                return encryptXorAB(base64ToBuffer(session.publicKeyB64), data);
            }
            else {
                return crypto.subtle.encrypt({ name: "aes-cbc", iv: base64ToBuffer(session.IV) }, cryptoKey, data);
            }
        }

        function decryptDataFromTheDevice(data) {
            if (session.encryptionType == "xorAB") {
                return decryptXorAB(base64ToBuffer(session.publicKeyB64), data);
            }
            return crypto.subtle.decrypt({ name: "aes-cbc", iv: base64ToBuffer(session.IV) }, cryptoKey, data);
        }

        function importSecretKey(rawKey) {
            return crypto.subtle.importKey("raw", rawKey, "aes-cbc", false, ["encrypt", "decrypt"])
        }
    </script>

    <!-- data transmission to the device via PROXY-->
    <script>
        function executeRequestB64(commandId, b64) {
            executeRequest(commandId, base64ToBuffer(b64))
        }
        const maxConcurentRequest = 2;
        var concurentRequest = 0;
        const spooler = [];
        function executeRequest(commandId, data) {
            spooler.push([commandId, data]);
            spoolingRequest();
        }
        function requestDone() {
            concurentRequest--;
            if (spooler.length > 0) {
                spoolingRequest();
            }
        }

        function spoolingRequest() {
            if (concurentRequest < maxConcurentRequest) {
                concurentRequest++;
                /*try {*/
                let toProcessing = spooler[spooler.length - 1];
                spooler.pop();
                let commandId = toProcessing[0];
                let data = toProcessing[1];
                //function executeRequest(commandId, data) {
                if (commandId == null) {
                    debugger;
                    console.log("Command does not exist");
                }
                if (!data) {
                    data = "";
                }
                if (typeof data === 'string') {
                    data = stringToBuffer(data);
                }
                let get = commandId == command.GetPushNotifications;
                let url = proxy + "/data?cid=" + encodeURIComponent(session.clientId);
                let purpose;
                if (commandId == command.SetClient || commandId == command.GetEncryptedQR) {
                    url += "&sid=" + encodeURIComponent(session.serverId);
                    purpose = getCommandName(commandId);
                    url += "&purpose=" + purpose; // SetClient Parameter is used only in debug that indicates whether a public encryption key is sent to the device. In releise the key is never sent it must be scanned by QR code
                }
                function onResponseError() {
                    debugger; //is status is 0, enable CORS in the server side: https://learn.microsoft.com/en-us/aspnet/core/security/cors?view=aspnetcore-6.0
                    alertBox("HTTP Request error " + this.status);
                    requestDone();
                }

                let request = new XMLHttpRequest();
                request.open(get ? "GET" : "POST", url);
                request.onerror = onResponseError;
                request.onabort = onResponseError;
                request.ontimeout = onResponseError;
                request.onload = function () {
                    requestDone();
                    if (this.status == 421) {
                        alertBox("status 421 = server the cloud is not logged into the proxy, please restart it");
                    } else if (this.readyState == this.DONE && this.status == 200 && this.responseText != "") {
                        if (session.QRkey) {
                            onCommandResponse.GetEncryptedQR(this.responseText);
                        } else if (session.deviceKey || session.encryptionType) {
                            // Use the generated key sent by the server
                            decryptResponse(this.responseText).then(decrypted => {
                                onResponse(decrypted);
                            });
                        } else {
                            // Use encryption with keys generated on the client
                            asymmetricalDecrypt(this.responseText).then(decrypted => {
                                onResponse(decrypted);
                            });
                        };
                    };
                }
                if (purpose) {
                    request.send(data);
                }
                else if (get) {
                    request.send();
                }
                else {
                    if (data == null) {
                        data = int32ToBuffer(commandId);
                    } else {
                        cmd = int32ToBuffer(commandId);
                        data = joinBuffers(cmd, data);
                    }
                    if (session == null || session.deviceKey == null) {
                        alertBox("Unregistered user. You need to log in to the server to initialize the encryption.");
                    } else {
                        encryptDataForTheDevice(data).then(encrypted => {
                            request.send(encrypted);
                        });
                    }
                }

                //} catch (e) {
                //    concurentRequest--;
                //}
            }
        }

        function onResponse(binary) {
            let commandId = bufferToInt(binary.slice(0, 4));
            let command = getCommandName(commandId);
            let data = binary.slice(4);
            let params = splitData(data);
            eval("onCommandResponse." + command + "(params)");
            //eval("onCommandResponse." + command).call(params);
            //  window["onCommandResponse." + command](params);
        }

        // Decrypt data encrypted with public key (shown by QR code)
        function asymmetricalDecrypt(encrypredResponseB64) {
            let encryptedData = base64ToBuffer(encrypredResponseB64);
            return decryptRsa(encryptedData);
        }

        function decryptResponse(encrypredResponseB64) {
            let encryptedData = base64ToBuffer(encrypredResponseB64);
            return decryptDataFromTheDevice(encryptedData);
        }

        // Read push notifications via polling
        function getPushNotifications() {
            if (isDebug == true)
                beep();
            let pollingSec = 10; // 10 sec.
            let currentFocus = document.hasFocus()
            if (lastHasFocus == false && currentFocus) {
                lastFocused = new Date();
            }
            lastHasFocus = currentFocus;
            let lastResponseSec = (new Date() - lastResponse) / 1000;
            let lastFocusedSec = (new Date() - lastFocused) / 1000;
            let diffSec = Math.min(lastResponseSec, lastFocusedSec);
            let h = document.hidden;
            let f = currentFocus;
            if (h || !f) {
                pollingSec = 600; // 10 min.
            } else {
                if (diffSec > 3600) { // > 1h
                    pollingSec = 600; // 10 min.
                } else if (diffSec > 60) { // > 1 min.
                    pollingSec = 60; // 1 min.
                }
            }
            if (((new Date() - lastPoll) / 1000) >= pollingSec) {
                lastPoll = new Date();
                executeRequest(command.GetPushNotifications);
            }
            setTimeout(getPushNotifications, 10000); // 10 ses.
        }
        var lastPoll = new Date();
        var lastResponse = new Date();
        var lastFocused = new Date();
        var lastHasFocus = document.hasFocus();
        var pushNotification = false; // allow / disallow polling for push notification
        if (pushNotification)
            setTimeout(getPushNotifications, 1000); // 1 ses.
    </script>

    <!-- COMMUNICATION PROTOCOL with the device via PROXY and events that are triggered when the proxy server REPLYES or send push NOTIFICATIONS: The proxy server sends data from the connected device-->
    <script>
        function getCommandName(commandId) {
            return enumToString(command, commandId);
        }
        const command = {
            SetClient: 0,
            Authentication: 1,
            Pair: 2,
            GetPushNotifications: 3,
            Error: 4,
            GetDir: 5,
            GetFile: 6,
            Share: 7,
            SetFile: 8,
            Delete: 9,
            Rename: 10,
            Move: 11,
            Copy: 12,
            CreateDir: 13,
            Search: 14,
            GetGroup: 15,
            AddToGroup: 16,
            RemoveFromGroup: 17,
            GetStorageInfo: 18,
            GetOccupiedSpace: 19,
            GetEncryptedQR: 20,
        }

        // Action that is performed when a response arrives to a command that has been sent
        const onCommandResponse = {
            SetClient: function (params) {
                alertBox("The device received the public key in debug mode!");
            },
            Authentication: function (params) {
                SaveClient();
                getDir("");
            },
            // Successful pairing with the device: When the device has scanned the QR code with the public key we receive the encryption key that we must use to send and receive commands to the server!
            Pair: function (params) {
                let clientIdHex = bufferToHex(params[0]);
                let deviceIV = params[2];
                let auth = params[3];
                if (clientIdHex != session.clientId) {
                    alertBox("Wrong connection, key verification failed!");
                } else if (session.deviceKey != undefined) {
                    alertBox("Attempt to change the encryption key!");
                }
                else {
                    if (params[1].byteLength > 0) {
                        session.encryptionType = "aes";
                        session.deviceKey = bufferToBase64(params[1]);
                        importSecretKey(params[1]).then(
                            key => {
                                // session.key = bufferToBase64(key);
                                cryptoKey = key;
                                session.IV = bufferToBase64(deviceIV);
                            }
                        );
                    } else {
                        session.encryptionType = "xorAB";
                    }
                }
                // Authentication
                authentication(auth);

            },
            Error: function (params) {
                let error = bufferToString(params[0]);
                alert(error);
            },
            GetDir: function (params) {
                let content = document.getElementById("content");
                content.innerHTML = "";
                setCloudPath(bufferToString(params[0]))
                document.getElementById("createDir").disabled = false;
                document.getElementById("getFavorities").disabled = false;
                let jsonObject = JSON.parse(bufferToString(params[1]));
                jsonObject.forEach(addFile);
                updateButtonsStatus();
            },
            GetFile: function (params, isShare) {
                if (isShare === undefined) {
                    isShare = false;
                }
                let jsonObject = JSON.parse(bufferToString(params[0]));
                let crc = jsonObject.Crc; // uint
                let fullName = jsonObject.FullName; // string
                let filename = fullName.replace(/^.*[\\\/]/, '')
                let dataBase64 = jsonObject.Data; // base64
                let chunkPart = jsonObject.ChunkPart;
                let totalChunk = jsonObject.TotalChunk;
                if (chunkPart == 1) {
                    download[fullName] = base64ToBuffer(dataBase64);
                } else {
                    download[fullName] = joinBuffers(download[fullName], base64ToBuffer(dataBase64));
                }
                let progressBar = pendingFiles[fullName];
                let progress = download[fullName].byteLength;
                progressBar.set(progress)
                if (chunkPart == totalChunk) {
                    downloadArrayBuffer(filename, download[fullName], isShare);
                    download[fullName] = null;
                } else {
                    getFile(fullName, chunkPart + 1);
                }
            },
            Share: function (params) {
                this.GetFile(params, true);
            },
            SetFile: function (params) {
                let nameFileAndChunk = bufferToString(params[0])
                let nameFileAndChunkParts = nameFileAndChunk.split("\t");
                let fullFileName = nameFileAndChunkParts[0];
                let nextChunkNumber = parseInt(nameFileAndChunkParts[1]) + 1;
                if (nextChunkNumber > chunkParts[fullFileName]) {
                    // upload completed successfully
                    pendingFiles[fullFileName].set(); // set progressBarr to end position, and remove the bar from the view
                    upload[fullFileName] = undefined;
                    chunkLength[fullFileName] = undefined;
                    chunkParts[fullFileName] = undefined;
                    let p = fullFileName.split("/");
                    p = p.slice(0, p.length - 1);
                    let path = p.join("/");
                    getDir(path);
                    // } else if (upload[fullFileName] != undefined) {
                    //     // send next chunk
                    //     setFile(fullFileName, nextChunkNumber, upload[fullFileName]);
                } else if (chunkRequest[fullFileName] != undefined) {
                    // Execute the event that asks for the next chunk to be sent
                    chunkRequestCallback = chunkRequest[fullFileName];
                    chunkRequestCallback(fullFileName, nextChunkNumber); // Notification that it is ready to receive the next file
                }
            },
            Delete: function (params) {
                this.GetDir(params);
            },
            Rename: function (params) {
                this.GetDir(params);
            },
            Move: function (params) {
                this.GetDir(params);
            },
            Copy: function (params) {
                this.GetDir(params);
            },
            CreateDir: function (params) {
                this.GetDir(params);
            },
            Search: function (params) {
                this.GetDir(params);
            },
            GetGroup: function (params) {
                this.GetDir(params);
            },
            AddToGroup: function (params) {
                this.GetDir(params);
            },
            RemoveFromGroup: function (params) {
                this.GetDir(params);
            },
            GetStorageInfo: function (params) {
                let freeSpace = bufferToString(params[0]);
                let usedSpace = bufferToString(params[1]);
                alertBox("used space = " + bytesToSize(usedSpace) + " ; free space = " + bytesToSize(freeSpace));
            },
            GetOccupiedSpace: function (params) {
                let path = bufferToString(params[0]);
                if (path == "") {
                    path = "cloud";
                }
                let regEx = bufferToString(params[1]);
                let spaceOccupied = bufferToString(params[2]);
                alertBox("space occupied in " + path + " by " + regEx + " is " + bytesToSize(spaceOccupied));
            },
            GetEncryptedQR: function (encryptedDataB64) {
                encryptedData = base64ToBuffer(encryptedDataB64);
                decryptXorAB(session.QRkey, encryptedData).then(data => {
                    session.QRkey = null;
                    let offset = 0;
                    let type = new Uint8Array(data.slice(offset, 1))[0];
                    if (type == 2) {
                        offset += 1;
                        let mSize = 2048 / 8; //NOTE: modules with sizes different of 2048 give an error during encryption in JavaScript
                        let modulus = data.slice(offset, offset + mSize);
                        offset += mSize;
                        let exponent = data.slice(offset, offset + 3);
                        importRsaPublicKey(modulus, exponent).then(rsaPubKey => {
                            setClient(rsaPubKey);
                        })
                    } else {
                        alertBox("QR code format not supported!")
                    }
                })
            }

        }

        function authentication(auth) {

            let pin = Number(document.getElementById("pin").value);
            let pin4 = int32ToBuffer(pin);
            let authentication = joinBuffers(auth, pin4);
            hash256(authentication).then(hash => {
                let verify = hash.slice(0, 4);
                executeRequest(command.Authentication, verify);
            });
        }
        function setClient(rsaPubKey) {
            session.deviceKey = null; // the server will send a new encryption key
            let clientPublicKey = base64ToBuffer(session.publicKeyB64);
            let clientSetting = joinBuffers(int32ToBuffer(chunkSize), int16ToBuffer(thumbnalSize));
            clientSetting = joinBuffers(clientSetting, clientPublicKey);
            encryptRsa(rsaPubKey, clientSetting).then(clientSettingEncrypted => {
                executeRequest(command.SetClient, clientSettingEncrypted);
            })
        }
        function getDir(path) {
            executeRequest(command.GetDir, path);
        }
        function getFile(fullFileName, chunkNumber) {
            // chunkNumber is base 1 (the first chunk is number 1)
            executeRequest(command.GetFile, fullFileName + "\t" + chunkNumber);
        }
        function share(fullFileName, chunkNumber) {
            // chunkNumber is base 1 (the first chunk is number 1)
            executeRequest(command.Share, fullFileName + "\t" + chunkNumber);
        }
        function setFile(fullFileName, chunkNumber, data, chunkRequestCallback) {
            // chunkNumber is base 1 (the first chunk is number 1)
            upload[fullFileName] = data;
            let fileLength = data.byteLength;
            let position = (chunkNumber - 1) * chunkSize;
            let toTake = fileLength - position;
            if (toTake > chunkSize)
                toTake = chunkSize;
            let chunkData = data.slice(position, position + toTake);
            uploadFile(fullFileName, chunkData, chunkNumber, fileLength, chunkRequestCallback)
        }
        function uploadFile(fullFileName, chunkData, chunkNumber, fileLength, chunkRequestCallback) {
            // fullFileName is the name with the full path to the destination, in unix format, example "pictures/logo.png"
            // chunkData is a data buffer which represents the chunk
            // chunkNumber is base 1 (the first chunk number must be 1)
            // fileLength is the overall length of the file being sent (byte length of file)
            // chunkRequestCallback is a function of the type chunkRequestCallback(fullFileName, chunkNumber) used as an event that is passed as a parameter in the first chunk, which will be called when the system is ready to receive the next chunk. This function will be used as an event that fires when the next chunk needs to be sent. Don't send chunks before this function is called! This function has a fullFileName parameter that will be passed when the function is called, and the chunkNumber parameter which indicates the requested chunk number (base 1).
            // Return true when the operation is completed or must be aborted (if it returns true, the operation must be aborted and no more chunks sent). Returns false if the operation must complete with sending the remaining ckunks to complete sending the file
            // NOTE: Important: You must never send two files with the same fullFileName simultaneously. This function returns true when you need to stop sending chunks (respect this!).
            if (chunkNumber <= 0) {
                debugger; // the first chunk number must be 1 !!
            }
            if (chunkRequestCallback != null) {
                chunkRequest[fullFileName] = chunkRequestCallback;
            }
            let lengthOfChunks;
            if (chunkData.byteLength == fileLength) {
                lengthOfChunks = fileLength;
            } else if (chunkNumber == 1) {
                lengthOfChunks = chunkData.byteLength;
                chunkLength[fullFileName] = lengthOfChunks;
            } else {
                lengthOfChunks = chunkLength[fullFileName]
            }
            let parts = Math.ceil(fileLength / lengthOfChunks);
            parts = parts == 0 ? 1 : parts;
            chunkParts[fullFileName] = parts;
            if (chunkNumber == 1) {
                // add the progress bar
                if (!addProgressBar(fullFileName, fileLength, true)) {
                    return true; // Operation with this file already in progress
                }
            }
            let position = (chunkNumber - 1) * lengthOfChunks;
            pendingFiles[fullFileName].set(position); // set position of progressBarr
            let File = {
                FullName: fullFileName,
                Data: bufferToBase64(chunkData),
                ChunkPart: chunkNumber,
                TotalChunk: parts,
            };
            executeRequest(command.SetFile, JSON.stringify(File));
            return false;
        }
        function delete_(path, files) {
            if (files) {
                if (Array.isArray(files)) {
                    files = files.join("\t");
                }
                executeRequest(command.Delete, path + "\t" + files);
            }
        }
        function rename(path, files, target) {
            if (files) {
                if (Array.isArray(files)) {
                    files = files.join("\t");
                }
                executeRequest(command.Rename, path + "\t" + files + "\t" + target);
            }
        }
        function move(path, files, target) {
            if (files) {
                if (Array.isArray(files)) {
                    files = files.join("\t");
                }
                executeRequest(command.Move, path + "\t" + files + "\t" + target);
            }
        }
        function copy(path, files, target) {
            if (files) {
                if (Array.isArray(files)) {
                    files = files.join("\t");
                }
                executeRequest(command.Copy, path + "\t" + files + "\t" + target);
            }
        }
        function createDir(path, files) {
            if (files) {
                if (Array.isArray(files)) {
                    files = files.join("\t");
                }
                executeRequest(command.CreateDir, path + "\t" + files);
            }
        }
        function search(path, wilscards, page, elementForPage) {
            // The wildcard can be replaced by regular expressions to perform advanced searches.
            // For pagination page is the page number (zero base), and elementsForPage indicates how many results are visible for each single page (-1 = do not limit the results).
            // NOTE about case sensitive: to search for files with partial text in the name, use "TextToFind" for the casese insensitive method, instead if you don't want to take case into account, use "*TextToFind*", or use this Regex for the insensitive case: "(?i)(TextToFind)"
            if (wilscards) {
                executeRequest(command.Search, path + "\t" + wilscards + "\t" + page + "\t" + elementForPage);
            }
        }
        function getGroup(groupName) {
            executeRequest(command.GetGroup, groupName);
        }
        function addToGroup(groupname, files) {
            if (files) {
                if (Array.isArray(files)) {
                    files = files.join("\t");
                }
                executeRequest(command.AddToGroup, groupname + "\t" + files);
            }
        }
        function removeFromGroup(groupname, files) {
            if (files) {
                if (Array.isArray(files)) {
                    files = files.join("\t");
                }
                executeRequest(command.RemoveFromGroup, groupname + "\t" + files);
            }
        }
        function GetStorageInfo() {
            executeRequest(command.GetStorageInfo);
        }
        function GetOccupiedSpace(path, wilscards) {
            // The wildcard can be replaced by regular expressions to perform advanced searches
            if (path == undefined) {
                path = "";
            }
            if (wilscards) {
                executeRequest(command.GetOccupiedSpace, path + "\t" + wilscards);
            }
        }
        function GetOccupiedSpaceOfImages(path) {
            GetOccupiedSpace(path, '[^\\s]+(.*?)\\.(jpg|jpeg|png|gif|ai|eps|svg|webp|JPG|JPEG|PNG|GIF|AI|EPS|SVG|WEBP)');
        }
        function GetOccupiedSpaceOfDocuments(path) {
            GetOccupiedSpace(path, '[^\\s]+(.*?)\\.(doc|docx|html|htm|odt|pdf|xls|xlsx|ods|ppt|pptx|txt|rtf|DOC|DOCX|HTML|HTM|ODT|PDF|XLS|XLSX|ODS|PPT|PPTX|TXT|RTF)');
        }
        function GetOccupiedSpaceOfVideo(path) {
            GetOccupiedSpace(path, '[^\\s]+(.*?)\\.(mp4|mov|avi|flv|mkv|wmv|avchd|webm|h264|mpg|mpeg|MP4|MOV|AVI|FLV|MKV|WMV|AVCHD|WEBM|H264|MPG|MPEG)');
        }
        function GetOccupiedSpaceOfAudio(path) {
            GetOccupiedSpace(path, '[^\\s]+(.*?)\\.(pcm|wav|aiff|mp3|acc|ogg|wma|flac|alac|aac|m4a|au|ac3|aa|aax|PCM|WAV|AIFF|MP3|ACC|OGG|WMA|FLAC|ALAC|AAC|M4A|AU|AC3|AA|AAX)');
        }
    </script>

    <!--functions that are triggered by the user-->
    <script>
        function dropHandler(ev) {
            console.log('File(s) dropped');
            // Prevent default behavior (Prevent file from being opened)
            ev.preventDefault();
            if (ev.dataTransfer.items) {
                // Use DataTransferItemList interface to access the file(s)
                for (let i = 0; i < ev.dataTransfer.items.length; i++) {
                    // If dropped items aren't files, reject them
                    if (ev.dataTransfer.items[i].kind === 'file') {
                        let file = ev.dataTransfer.items[i].getAsFile();
                        console.log('... file[' + i + '].name = ' + file.name);
                        startSendFile(file, true);
                    }
                }
            } else {
                // Use DataTransfer interface to access the file(s)
                for (let i = 0; i < ev.dataTransfer.files.length; i++) {
                    let file = ev.dataTransfer.files[i];
                    console.log('... file[' + i + '].name = ' + file.name);
                    startSendFile(file, true);
                }
            }
        }
        function startSendFile(file, async) {
            if (async) {
                setTimeout(startSendFile(file, false), 1);
                return;
            }
            let fr = new FileReader();
            fr.onload = function () {
                let data = fr.result;

                let fullname;
                if (currentPath == "") {
                    fullname = file.name
                } else {
                    fullname = currentPath + "/" + file.name;
                }
                function chunkRequestCallback(fullFileName, numberOfChunksRequested) {
                    // This function will be called as an event when the system requests to send the next chunk
                    // Function that is called to ask for the following chunk
                    setFile(fullFileName, numberOfChunksRequested, upload[fullFileName]);
                }
                setFile(fullname, 1, data, chunkRequestCallback)
                //setFile(currentPath + "/" + file.name, 1, data)
            };
            fr.readAsArrayBuffer(file);
        }

        function pickFile(input) {
            let fileTypes = ['jpg', 'jpeg', 'png', 'webp'];  //acceptable file types
            if (input.files && input.files[0]) {
                var extension = input.files[0].name.split('.').pop().toLowerCase(),
                    isSuccess = fileTypes.indexOf(extension) > -1;
                if (isSuccess) {
                    let reader = new FileReader();
                    reader.onload = function (e) {
                        if (e.target.result.startsWith("data:image")) {
                            resizeImage(e, 800).then(scaled => {
                                let b64 = dataURLtoBase64(scaled);
                                sendMessage("Image", b64);
                            });
                        }
                    }
                    reader.readAsDataURL(input.files[0]);
                }
                else { alert("Unsupported data type"); }
            }
        }

    </script>

    <!--functions to dynamically add HTML elements to the page-->
    <script>
        function addProgressBar(text, max, isUplload) {
            if (pendingFiles[text] == undefined || pendingFiles[text] == null) {
                let container = document.createElement("container");
                pendingFiles[text] = container;
                let ico = '\u2b07';
                if (isUplload) {
                    ico = '\u2b06';
                }
                let label = document.createElement("label");
                label.for = text;
                label.innerText = ico + text;
                let progressBar = document.createElement("progress");
                container.appendChild(label);
                container.appendChild(progressBar);
                progressBar.id = text;
                progressBar.max = max;
                progressBar.value = 0;
                progressBar.className = "progressBar";
                let topBar = document.getElementById("topBar");
                container.remove = function (position) {
                    pendingFiles[text] = null;
                    topBar.removeChild(container);
                }
                container.set = function (value) {
                    if (value == undefined) {
                        value = progressBar.max;
                    }
                    clearTimeout(container.timeout);
                    //percentage = round((value / max) * 100);
                    //bar.style.width = percentage + "%";
                    progressBar.value = value;
                    if (value == progressBar.max) {
                        container.remove();
                    }
                    else {
                        container.timeout = setTimeout(container.remove, 600000);
                    }
                }
                let timeout = setTimeout(container.remove, 600000);
                container.timeout = timeout;
                topBar.appendChild(container);
                return true; // The operation was successful, the taskbar has been created and the file can be transferred
            }
            return false; // Operation with this file already in progress
        }

        function removeAllChildNodes(parent) {
            while (parent.firstChild) {
                parent.removeChild(parent.firstChild);
            }
        }
        function addFile(file, idx) {
            let content = document.getElementById("content");
            if (idx == 0) {
                content.innerHTML = "";
            }
            let fileContainer = document.createElement("span");
            fileContainer.className = "fileContainer";
            let checkbox = document.createElement("input");
            checkbox.type = "checkbox";
            checkbox.className = "fileSelector"
            checkbox.id = "idx" + idx;
            checkbox.file = file;
            checkbox.onclick = updateButtonsStatus;

            let fileItemBox = document.createElement("label");
            fileItemBox.for = checkbox.id;
            fileItemBox.className = "fileItemBox";

            if (file.IsDirectory) {
                fileItemBox.onclick = function (event) {
                    getDir(currentPath + "/" + file.Name);
                }
            } else {
                fileItemBox.onclick = function (event) {
                    let fullname;
                    if (currentPath == "") {
                        fullname = file.Name
                    } else {
                        fullname = currentPath + "/" + file.Name;
                    }
                    if (!addProgressBar(fullname, file.Length, false)) {
                        return; // Operation with this file already in progress
                    }
                    if (event.shiftKey || event.ctrlKey || event.altKey) {
                        share(fullname, 1);
                    } else {
                        getFile(fullname, 1);
                    }
                }
            }
            let thumbnail = document.createElement("div");
            thumbnail.className = "thumbnail";
            if (file.Thumbnail != null) {
                thumbnail.style.backgroundImage = 'url("' + "data:image/jpg;base64," + file.Thumbnail + '")';
            }
            else {
                if (file.IsDirectory) {
                    thumbnail.style.backgroundImage = "url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAEAAAAAuCAMAAACvSe/GAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAxhpVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuMC1jMDYwIDYxLjEzNDM0MiwgMjAxMC8wMS8xMC0xODowNjo0MyAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIENTNSIgeG1wTU06SW5zdGFuY2VJRD0ieG1wLmlpZDpEMzdEOEQ5OUM2RTUxMUVDOTIxQkRDMzhGMzM0Qzg1NCIgeG1wTU06RG9jdW1lbnRJRD0ieG1wLmRpZDpEMzdEOEQ5QUM2RTUxMUVDOTIxQkRDMzhGMzM0Qzg1NCI+IDx4bXBNTTpEZXJpdmVkRnJvbSBzdFJlZjppbnN0YW5jZUlEPSJ4bXAuaWlkOkQzN0Q4RDk3QzZFNTExRUM5MjFCREMzOEYzMzRDODU0IiBzdFJlZjpkb2N1bWVudElEPSJ4bXAuZGlkOkQzN0Q4RDk4QzZFNTExRUM5MjFCREMzOEYzMzRDODU0Ii8+IDwvcmRmOkRlc2NyaXB0aW9uPiA8L3JkZjpSREY+IDwveDp4bXBtZXRhPiA8P3hwYWNrZXQgZW5kPSJyIj8+P9pX5wAAAAZQTFRF+MY9////OAw5rgAAAAJ0Uk5T/wDltzBKAAAANklEQVR42uzNsQ0AMAwCQdh/aStdZFHEcfvX88iHGr9T2k8KCusJh8vP0jagdQAAAAC4lAADAKWtAIHPdBpOAAAAAElFTkSuQmCC')";
                }
                else {
                    let text = file.Name.charAt(0);
                    let name = file.Name.toLowerCase();
                    const docs = [".doc", ".docx", ".rtf", ".odt", ".txt", ".pdf"];
                    const images = [".jpg", ".jpeg", ".png", ".gif", ".ai", ".eps", ".svg", "webp"];
                    const videos = [".mp4", ".mov", ".avi", ".flv", ".mkv", ".wmv", ".avchd", "webm", ".h264", ".mpg", ".mpeg"];
                    const audios = [".pcm", ".wav", ".aiff", ".mp3", ".acc", ".ogg", ".wma", ".flac", "alac", ".aac", ".m4a", ".au", ".ac3", ".aa", ".aax"];
                    const exes = [".apk", ".bat", ".bin", ".cgi", ".com", ".exe", ".jar", ".py", ".wsf"];
                    const Spreadsheets = [".ods", ".xlr", ".xls", ".xlsx"];
                    const presentations = [".key", ".odp", ".pps", ".ppt", ".pptx"];
                    const databases = [".accdb", ".csv", ".dat", ".db", ".dbf", ".log", ".mdb", ".pdb", ".sav", ".sql"];
                    const compresses = [".zip", ".tar", ".wim", ".7z", ".rar", ".gz"];
                    if (docs.find(x => name.endsWith(x))) {
                        text = "\uD83D\uDDCE";
                    } else if (images.find(x => name.endsWith(x))) {
                        text = "\uD83D\uDDBC";
                    } else if (videos.find(x => name.endsWith(x))) {
                        text = "\uD83C\uDF9E";
                    } else if (audios.find(x => name.endsWith(x))) {
                        text = "\uD83D\uDD6A";
                    } else if (exes.find(x => name.endsWith(x))) {
                        text = "\u2386";
                    } else if (Spreadsheets.find(x => name.endsWith(x))) {
                        text = "\uD83D\uDDA9";
                    } else if (presentations.find(x => name.endsWith(x))) {
                        text = "\u23F5";
                    } else if (databases.find(x => name.endsWith(x))) {
                        text = "\u23F5";
                    } else if (compresses.find(x => name.endsWith(x))) {
                        text = "\uD83D\uDDDC";
                    }
                    thumbnail.appendChild(document.createTextNode(text));
                }
            }
            fileItemBox.appendChild(thumbnail);

            let fileName = document.createElement("span");
            fileName.innerText = file.Name;
            fileName.className = "fileProperty fileName";
            fileItemBox.appendChild(fileName);

            let fileLength = document.createElement("span");
            if (file.Length != null) {
                fileLength.innerText = file.Length + " bytes";
            }
            fileLength.className = "fileProperty fileLength";
            fileItemBox.appendChild(fileLength);

            let fileDate = document.createElement("span");
            let date = new Date(file.Date);
            fileDate.innerText = date.toLocaleString();
            fileDate.className = "fileProperty fileDate";
            fileItemBox.appendChild(fileDate);
            if (!file.Name.endsWith(".")) {
                fileContainer.appendChild(checkbox);
            }
            fileContainer.appendChild(fileItemBox);
            content.appendChild(fileContainer);
        }
        function allFileSelected() {
            let result = [];
            let checkBoxs = document.getElementsByTagName('input');
            for (let i = 0; i < checkBoxs.length; i++) {
                if (checkBoxs[i].className == "fileSelector") {
                    if (checkBoxs[i].checked == true) {
                        result.push(checkBoxs[i].file);
                    }
                }
            }
            return result;
        }
        function getFilesName() {
            let all = allFileSelected();
            let files = [];
            for (let i = 0; i < all.length; i++) {
                let file = all[i];
                files.push(file.Name);
            }
            return files;
        }

        function onDeleteButton() {
            let files = getFilesName();
            if (files.length != 0) {
                delete_(currentPath, files)
            }
        }

        function onRenameButton() {
            let files = getFilesName();
            if (files.length != 0) {
                let target = window.prompt("Enter a new name", files[0]);
                rename(currentPath, files, target);
            }
        }

        function onMoveButton() {
            let files = getFilesName();
            if (files.length != 0) {
                let target = document.getElementById("target");
                target.files = files;
                target.sourcePath = currentPath;
                target.command = command.Move;
                goToTarget(true);
            }
        }

        function onCopyButton() {
            let files = getFilesName();
            if (files.length != 0) {
                let target = document.getElementById("target");
                target.files = files;
                target.sourcePath = currentPath;
                target.command = command.Copy;
                goToTarget(true);
            }
        }

        function onAddToFavorities() {
            let files = getFilesName();
            if (currentPath != "") {
                for (var i = 0; i < files.length; i++) {
                    files[i] = currentPath + "/" + files[i];
                }
            }
            if (files.length != 0) {
                addToGroup("favorities", files);
            }
        }

        function onRemoveFromFavorities() {
            let files = getFilesName();
            if (currentPath != "") {
                for (var i = 0; i < files.length; i++) {
                    files[i] = currentPath + "/" + files[i];
                }
            }
            if (files.length != 0) {
                removeFromGroup(currentGroup, files);
            }
        }

        function onGetFavorities() {
            getGroup("favorities");
        }

        function onCreateDirButton() {
            let dirName = window.prompt("Enter new folder name", "New directory");
            createDir(currentPath, dirName);
        }

        function onTargetButton(event) {
            let target = event.target;
            if (target.files != null && target.files.length != 0) {
                if (target.command == command.Move && target.sourcePath != currentPath) {
                    move(target.sourcePath, target.files, currentPath);
                }
                else if (target.command == command.Copy) {
                    let paste = currentPath;
                    if (target.sourcePath == currentPath && target.files.length == 1) {
                        paste = window.prompt("Enter a name of copy", "copy_" + files[0]);
                    }
                    copy(target.sourcePath, target.files, paste);
                }
            }
            target.files = null;
            goToTarget(false);
        }

        function goToTarget(startGoTo) {
            document.getElementById("delete").disabled = startGoTo;
            document.getElementById("rename").disabled = startGoTo;
            document.getElementById("move").disabled = startGoTo;
            document.getElementById("copy").disabled = startGoTo;
            let addFav = startGoTo;
            if (currentGroup) {
                addFav = true;
            }
            document.getElementById("addToFavorities").disabled = addFav;
            let removeFav = startGoTo;
            if (!currentGroup) {
                removeFav = true;
            }
            document.getElementById("removeFromFavorities").disabled = removeFav;
            document.getElementById("target").disabled = !target.files;
        }

        function updateButtonsStatus() {
            let disabled = allFileSelected().length == 0;
            goToTarget(disabled);
            //document.getElementById("target").disabled = !disabled;
        }

        function onSearch(event) {
            if (event.keyCode === 13) {
                console.log("Enter key pressed!!!!!");
                let searchObj = event.target;
                let wildcard = searchObj.value;
                //searchObj.value = "";
                search(currentPath, wildcard, 0, -1);
            }
        }

        async function onQrCodeAcquires(qrCode, sessionId) {
            // Reset the type of encryption (this will be communicated by the server)

            await NewSession(sessionId);

            let qr = base64ToBuffer(qrCode);
            let offset = 0;
            let type = new Uint8Array(qr.slice(offset, 1))[0];
            offset += 1;
            if (type == 1) {
                let mSize = 2048 / 8; //NOTE: modules with sizes different of 2048 give an error during encryption in JavaScript
                let modulus = qr.slice(offset, offset + mSize);
                offset += mSize;
                let exponent = qr.slice(offset, offset + 3);
                offset += 3;
                let serverPublicKey = qr.slice(offset, offset + 33);
                offset += 33;
                session.entryPoint = bufferToString(qr.slice(offset)); // proxy            
                // entryPoint = "server.cloudservices.agency";
                await entryPointToProxy(session.entryPoint);
                hash256(serverPublicKey).then(hash => {
                    session.serverId = bufferToHex(hash.slice(0, 8));
                    importRsaPublicKey(modulus, exponent).then(rsaPubKey => {
                        setClient(rsaPubKey);
                    })
                })
            }
            else if (type == 2) {
                session.QRkey = qr.slice(offset, offset + 24);
                offset += 24;
                session.serverId = bufferToHex(qr.slice(offset, offset + 8));
                offset += 8;
                session.entryPoint = bufferToString(qr.slice(offset)); // proxy                    
                // entryPoint = "server.cloudservices.agency";
                await entryPointToProxy(session.entryPoint);
                executeRequest(command.GetEncryptedQR)
            } else {
                alertBox("QR code format not supported!")
            }
        }

        async function entryPointToProxy(ep) {
            if (ep == null || ep == "") {
                ep = "server.cloudservices.agency";
            } else if (ep.indexOf(".") == -1) {
                ep = ep + ".cloudservices.agency";
            }
            let json = await resolveDNS(ep);
            if (json.Answer && json.Answer.length > 0) {
                ep = json.Answer[0].data;
            }
            if (!ep.startsWith("http")) {
                ep = "http://" + ep;
            }
            proxy = ep;
            if (proxy.replace("://", "").indexOf(":") == -1) {
                proxy += ":" + defaultProxyPort;
            }
        }

        function resolveUrl(url) {
            if (url.indexOf("~/") == 0) {
                url = baseUrl + url.substring(2);
            }
            return url;
        }

        function clone(obj) {
            let clone = document.createElement(obj.tagName);
            clone.innerHTML = obj.innerHTML;
            clone.id = null;
            clone.className = obj.className + " reply";
            return clone;
        }

        function setCloudPath(path) {
            if (path.startsWith(":")) {
                currentPath = "";
                currentGroup = path;
            } else {
                currentPath = path;
                currentGroup = null;
            }
            let cloudPath = document.getElementById("cloudPath");
            cloudPath.innerHTML = "";
            let parts = path.split("/");
            if (parts[0] != "")
                parts.unshift("");
            let fullDir = "";
            parts.forEach(dir => {
                let button = document.createElement("button");
                button.innerText = dir;
                if (button.innerText == "") {
                    button.innerText = "cloud";
                }
                fullDir += dir;
                if (dir.startsWith(":")) {
                    button.dirName = dir;
                    button.onclick = function (event) {
                        getGroup(event.target.dirName);
                    }
                } else {
                    button.dirName = fullDir;
                    button.onclick = function (event) {
                        getDir(event.target.dirName);
                    }
                }
                cloudPath.appendChild(button);
                fullDir += "/";
            });
        }

    </script>

    <!--Initialization functions that are performed when the browser is started-->
    <script>
        var privateKey;// This key is generated in the browser, it is used to decrypt the data sent by the device. This key never leaves the browser, and the JavaScript code in source format is proof that no one has access to the communication between device and browser!
        var publicKey; // Generated in the browser, it is scanned by the device with the QR code and used to encrypt the data from the device to the browser without intermediaries
        var cryptoKey // Object used for encrypt/decrypt
        var hashPubKeyBase64 = "";
        var currentPath = "";
        var currentGroup = null;
        var download = [];
        var upload = [];
        var chunkLength = [];
        var chunkParts = [];
        var chunkRequest = [];
        var setupQr = false;
        var chunkSize = 1024 * 256; // The size of the chunks (blocks) for the file transfer. Set 0 to let the server decide the size of the chunks
        var thumbnalSize = 80; // Parameter that is passed to the server and indicates the size of the larger side of the image preview
        var defaultProxyPort = 5050;
        var session = {
            id: null,
            entryPoint: null,
            serverId: null,
            clientId: null,
            publicKeyB64: null, // This key must be generated by the Javascript in the browser
            encryptionType: null, // Indicates the type of encryption that is set for communication, it can be aes or xorAB for if aes encryption is not supported
            deviceKey: null, // Is the aes-cbc key that was generated by the device and you need to encrypt any data sent to the device using this key!
            IV: null,
            QRkey: null, // Key added in the QR code type 2 implementation, it is used to decrypt the QR code data sent via proxy
        }
        var proxy = "http://proxy.cloudservices.agency:" + defaultProxyPort;
        var pendingFiles = []; // dictionary for progress bars of download operations
        if (isDebug) {
            proxy = "https://localhost:7060";
        }

        let reset = false;
        if (reset) {
            DeleteClient(); // Logout and delete current client account == LOGOUT ==
        } else {
            // Load last Client if exist, in order to remain logged in the previous session
            // NOTE: In production this function must be protected by a pin, or the application must ask for a pin at startup
            LoadClient(0).then(loaded => {
                if (!loaded) {
                    NewSession(); // If a saved session was not found, create a new one
                }
            })
        }




    </script>

    <style>
        html,
        body {
            margin: 0;
            padding: 0;
            background-color: #1f1f1f;
            color: white;
            font-family: sans-serif;
            scrollbar-color: dark;
        }

        fieldset {
            border: 4px rgba(0, 0, 0, 0.5) solid;
            margin: 5px 30px 5px 30px;
        }

        legend {
            border: 4px rgba(0, 0, 0, 0.5) solid;
        }


        /*        legend {
                    style ="border: 4px grey solid; margin-left: 1em; padding: 0.2em 0.8em "
                }
        */
        progress {
            margin: 0px 10px 0px 10px;
        }

        ::-webkit-scrollbar {
            width: 10px;
            height: 10px;
        }

        ::-webkit-scrollbar-thumb {
            background: rgba(90, 90, 90);
        }

        ::-webkit-scrollbar-track {
            background: rgba(0, 0, 0, 0.5);
        }

        /* use viewport-relative units to cover page fully */
        body {
            height: 100vh;
            width: 100vw;
        }

        .container {
            height: 100%;
            margin: auto;
            width: 1300px;
            background: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' height='100%25' width='100%25'%3E%3Cdefs%3E%3Cpattern id='doodad' width='77.94' height='135' viewBox='0 0 34.64101615137755 60' patternUnits='userSpaceOnUse' patternTransform='rotate(135)'%3E%3Crect width='100%25' height='100%25' fill='rgba(42, 67, 101,1)'/%3E%3Cpath d='M51.96 30L51.96 50L34.64 60L34.64 40z' stroke-linejoin='miter' fill='rgba(26, 32, 44,1)'/%3E%3Cpath d='M17.32 30L17.32 50L0 60L0 40z' stroke-linejoin='miter' fill='rgba(26, 32, 44,1)'/%3E%3Cpath d='M34.64 0L34.64 20L17.32 30L17.32 10z' stroke-linejoin='miter' fill='rgba(26, 32, 44,1)'/%3E%3Cpath d='M34.64 60L34.64 80L17.32 90L17.32 70z' stroke-linejoin='miter' fill='rgba(26, 32, 44,1)'/%3E%3Cpath d='M34.64 60L17.32 50L17.32 30L34.64 40z' stroke-linejoin='miter' fill='rgba(40, 94, 97,1)'/%3E%3Cpath d='M0 60L-17.32 50L-17.32 30L0 40z' stroke-linejoin='miter' fill='rgba(40, 94, 97,1)'/%3E%3Cpath d='M17.32 30L0 20L0 0L17.32 10z' stroke-linejoin='miter' fill='rgba(40, 94, 97,1)'/%3E%3Cpath d='M17.32 90L0 80L0 60L17.32 70z' stroke-linejoin='miter' fill='rgba(40, 94, 97,1)'/%3E%3Cpath d='M34.64 40L34.64 40L34.64 40L34.64 40z' stroke-linejoin='miter' fill='rgba(26, 32, 44,1)'/%3E%3Cpath d='M0 40L0 40L0 40L0 40z' stroke-linejoin='miter' fill='rgba(26, 32, 44,1)'/%3E%3Cpath d='M17.32 10L17.32 10L17.32 10L17.32 10z' stroke-linejoin='miter' fill='rgba(26, 32, 44,1)'/%3E%3Cpath d='M17.32 70L17.32 70L17.32 70L17.32 70z' stroke-linejoin='miter' fill='rgba(26, 32, 44,1)'/%3E%3Cpath d='M34.64 40L34.64 40L34.64 40L34.64 40z' stroke-linejoin='miter' fill='rgba(40, 94, 97,1)'/%3E%3Cpath d='M0 40L0 40L0 40L0 40z' stroke-linejoin='miter' fill='rgba(40, 94, 97,1)'/%3E%3Cpath d='M17.32 10L17.32 10L17.32 10L17.32 10z' stroke-linejoin='miter' fill='rgba(40, 94, 97,1)'/%3E%3Cpath d='M17.32 70L17.32 70L17.32 70L17.32 70z' stroke-linejoin='miter' fill='rgba(40, 94, 97,1)'/%3E%3Cpath d='M34.64 40L34.64 40L34.64 40L34.64 40z' stroke-linejoin='miter' background='true' fill='rgba(26, 32, 44,1)'/%3E%3Cpath d='M0 40L0 40L0 40L0 40z' stroke-linejoin='miter' background='true' fill='rgba(26, 32, 44,1)'/%3E%3Cpath d='M17.32 10L17.32 10L17.32 10L17.32 10z' stroke-linejoin='miter' background='true' fill='rgba(26, 32, 44,1)'/%3E%3Cpath d='M17.32 70L17.32 70L17.32 70L17.32 70z' stroke-linejoin='miter' background='true' fill='rgba(26, 32, 44,1)'/%3E%3Cpath d='M34.64 40L34.64 40L34.64 40L34.64 40z' stroke-linejoin='miter' fill='rgba(40, 94, 97,1)'/%3E%3Cpath d='M0 40L0 40L0 40L0 40z' stroke-linejoin='miter' fill='rgba(40, 94, 97,1)'/%3E%3Cpath d='M17.32 10L17.32 10L17.32 10L17.32 10z' stroke-linejoin='miter' fill='rgba(40, 94, 97,1)'/%3E%3Cpath d='M17.32 70L17.32 70L17.32 70L17.32 70z' stroke-linejoin='miter' fill='rgba(40, 94, 97,1)'/%3E%3Cpath d='M34.64 40L34.64 40L34.64 40L34.64 40z' stroke-linejoin='miter' fill='rgba(26, 32, 44,1)'/%3E%3Cpath d='M0 40L0 40L0 40L0 40z' stroke-linejoin='miter' fill='rgba(26, 32, 44,1)'/%3E%3Cpath d='M17.32 10L17.32 10L17.32 10L17.32 10z' stroke-linejoin='miter' fill='rgba(26, 32, 44,1)'/%3E%3Cpath d='M17.32 70L17.32 70L17.32 70L17.32 70z' stroke-linejoin='miter' fill='rgba(26, 32, 44,1)'/%3E%3Cpath d='M34.64 40L34.64 40L34.64 40L34.64 40z' stroke-linejoin='miter' background='true' fill='rgba(40, 94, 97,1)'/%3E%3Cpath d='M0 40L0 40L0 40L0 40z' stroke-linejoin='miter' background='true' fill='rgba(40, 94, 97,1)'/%3E%3Cpath d='M17.32 10L17.32 10L17.32 10L17.32 10z' stroke-linejoin='miter' background='true' fill='rgba(40, 94, 97,1)'/%3E%3Cpath d='M17.32 70L17.32 70L17.32 70L17.32 70z' stroke-linejoin='miter' background='true' fill='rgba(40, 94, 97,1)'/%3E%3Cpath d='M34.64 40L34.64 40L34.64 40L34.64 40z' stroke-linejoin='miter' fill='rgba(26, 32, 44,1)'/%3E%3Cpath d='M0 40L0 40L0 40L0 40z' stroke-linejoin='miter' fill='rgba(26, 32, 44,1)'/%3E%3Cpath d='M17.32 10L17.32 10L17.32 10L17.32 10z' stroke-linejoin='miter' fill='rgba(26, 32, 44,1)'/%3E%3Cpath d='M17.32 70L17.32 70L17.32 70L17.32 70z' stroke-linejoin='miter' fill='rgba(26, 32, 44,1)'/%3E%3Cpath d='M34.64 40L34.64 40L34.64 40L34.64 40z' stroke-linejoin='miter' fill='rgba(40, 94, 97,1)'/%3E%3Cpath d='M0 40L0 40L0 40L0 40z' stroke-linejoin='miter' fill='rgba(40, 94, 97,1)'/%3E%3Cpath d='M17.32 10L17.32 10L17.32 10L17.32 10z' stroke-linejoin='miter' fill='rgba(40, 94, 97,1)'/%3E%3Cpath d='M17.32 70L17.32 70L17.32 70L17.32 70z' stroke-linejoin='miter' fill='rgba(40, 94, 97,1)'/%3E%3Cpath d='M34.64 40L34.64 40L34.64 40L34.64 40z' stroke-linejoin='miter' background='true' fill='rgba(26, 32, 44,1)'/%3E%3Cpath d='M0 40L0 40L0 40L0 40z' stroke-linejoin='miter' background='true' fill='rgba(26, 32, 44,1)'/%3E%3Cpath d='M17.32 10L17.32 10L17.32 10L17.32 10z' stroke-linejoin='miter' background='true' fill='rgba(26, 32, 44,1)'/%3E%3Cpath d='M17.32 70L17.32 70L17.32 70L17.32 70z' stroke-linejoin='miter' background='true' fill='rgba(26, 32, 44,1)'/%3E%3C/pattern%3E%3C/defs%3E%3Crect fill='url(%23doodad)' height='200%25' width='200%25'/%3E%3C/svg%3E ");
        }

        /* include border and padding in element width and height */
        * {
            box-sizing: border-box;
        }

        /*        section {
                    height: 100%;
                    background-color: red;
                    display: flex;
                }*/
        .topBar {
            height: 200px;
            /*if you change, change too .main height value */
        }

        .main {
            height: calc(100% - 200px);
            overflow-wrap: break-word;
            flex-direction: column-reverse;
        }

        .topBar {
            background-color: rgb(66, 66, 66, 0.70);
        }

        .sidebar {
            box-shadow: rgba(0, 0, 0, 0.2) 0px 10px 20px, rgba(0, 0, 0, 0.3) 0px 6px 6px;
            background-color: rgb(66, 66, 66, 0.70);
            height: 100%;
            width: 20%;
            float: left;
            overflow-x: hidden;
            overflow-y: auto;
        }

        canvas {
            display: block;
        }

        .fileItemBox {
            display: flex;
            margin: 5px;
        }

        .fileItemBox:active,
        button:active:enabled,
        label:active:enabled {
            transition: transform .2s;
            transform: scale(0.9);
            cursor: pointer;
        }

        .fileItemBox:hover,
        button:hover,
        label:hover {
            background-color: #ffffff1e;
        }

        .fileProperty {
            margin: auto auto auto 30px;
            font-size: small;
        }

        .expand {
            width: 100%;
            margin-right: 0px !important;
            margin-left: 0px !important;
        }

        .fileName {
            width: 50%;
        }

        .fileLength {
            width: 25%;
        }

        .fileDate {
            width: 25%;
        }

        .thumbnail {
            padding: 0px;
            width: 50px;
            height: 50px;
            text-align: center;
            font-size: 3em;
            background-size: contain;
            background-repeat: no-repeat
        }

        .content {
            display: flow-root;
            height: calc(100% - 200px);
            overflow-x: hidden;
            overflow-y: scroll;
        }

        .fileItemBox {
            box-shadow: rgba(0, 0, 0, 0.2) 0px 10px 20px, rgba(0, 0, 0, 0.3) 0px 6px 6px;
            padding-left: 50px;
            width: 100%;
        }

        .fileContainer {
            display: flex;
        }

        .fileSelector {
            margin: 25px;
        }

        /*      .message {
                    border-radius: 20px;
                    padding: 20px;
                    margin: 20px;
                    margin-right: 60px;
                    margin-left: 60px;
                    width: 700px;
                    font-size: larger;
                }*/

        .my {
            float: right;
            background-color: darkcyan;
        }

        .others {
            float: left;
            background-color: rgb(0, 0, 0, 0.69);
        }

        .messageImage:hover {
            transition: transform .5s;
            transform: scale(1.5);
        }

        .bottom {
            display: flex;
            border-radius: 25px;
            padding: 20px;
            position: relative;
            bottom: -30px;
            left: 30px;
            width: calc(80% - 60px);
            height: 140px;
            background-color: rgb(66, 66, 66, 0.70);
            box-shadow: rgba(0, 0, 0, 0.2) 0px 10px 20px, rgba(0, 0, 0, 0.3) 0px 6px 6px;
        }

        .functionButton {
            margin-left: 20px;
            font-size: xx-small;
            padding-bottom: -20px;
            padding: 10px;
            background-color: transparent;
            color: white;
            box-shadow: rgba(0, 0, 0, 0.2) 0px 10px 20px, rgba(0, 0, 0, 0.3) 0px 6px 6px;
            border-width: 2px;
            border-style: outset;
            border-color: #77777790;
        }

        .functionButton:disabled {
            background-color: rgba(0, 0, 0, 0.3);
            color: rgba(255, 255, 255, 0.1)
        }

        .drag-over {
            border: dashed 3px red;
        }

        input {
            height: min-content;
            margin: 5px;
            background-color: darkgray;
        }

        .largeFont {
            font-size: larger
        }

        .info {
            margin: 20px;
            color: lightgrey;
        }
    </style>
</head>

<body>
    <section class="container" ondrop="dropHandler(event);" onDragOver="event.preventDefault();">
        <section id="topBar" class="topBar">
            <div id="alertBox" class="alertBox"></div><br />
            <fieldset>
                <legend>Path</legend>
                <div id="cloudPath" class="fileName"></div>
            </fieldset>

        </section>
        <section id="main" class="main">
            <aside id="sidebare" class="sidebar">
                <button onclick="GetStorageInfo();" class="functionButton expand">Get storage info</button>
                <button onclick="GetOccupiedSpaceOfImages();" class="functionButton expand">Get occupied space of
                    pictures</button>
                <!-- To enter it is not necessary to login, you can retrieve the saved session, in production this function must be protected by a pin -->
                <button onclick="LoadClient(0);" class="functionButton expand">Load session</button>
                <!-- freeze the current session state on the cloud to enter without having to create a new client -->
                <button onclick="SaveClient();" class="functionButton expand">Save session</button>
                <!-- You can destroy any saved sessions, however it is recommended to keep the saved session, and protect the upload with an application access pin                 -->
                <button onclick="DeleteClient();" class="functionButton expand">Delete this session</button>
            </aside>
            <section id="content" class="content">

                <fieldset>
                    <legend>QR</legend>
                    <label for="qr">QR code on cloud</label>
                    <!--<input id="qr" type="text" value="">-->
                    <input id="qr" type="text" value="">
                    <label for="pin">Pin</label>
                    <!--<input id="pin" type="password" value="">-->
                    <input id="pin" type="password" value="">
                    <!--The server has protection against brute force attacks, it is not allowed to make attempts in less than 5 seconds, so you must disable the button this period or more-->
                    <button id="connect" onclick="this.disabled = true; setTimeout(() => this.disabled = false, 30000) // 30 sec. is the timeout on proxy site for answare;
                        ; onQrCodeAcquires(document.getElementById('qr').value);"
                        class="functionButton">Connect</button>
                    <script>
                        if (isDebug) { /*Set default values for the test*/
                            //qr.value = "AajqOfum5xcWmCZ5Fd4X+RLQkjoAsA9HUraB/LxcNVlLtwACOiqpQIF/+K/pLopmGX3QE8fnIvldLn4wePUPGgz6hShLW2kKqHt8EgQwF05YaeQBBohpjuDbK/McfqM2asjXmHIMm8nx/ZB1GNJsFROVdWSrN8bRbR+QEY/c/rP9YyaZcAtSrlLQsT27w/2thgTcjXv2I19RcQjhaNXyRhITvjNPTNx5XVEVYdEh9xU8s4uOX760kZhwvAiGMar6AzW+FyMDCvYJQ2+4FUZfmeDvwsB9B5+futj/+pylsWheYU5TwVYMeSS7j/rKniIUO4E/36FVQ2O+GaIB8re+koEBAAED3A4+AuDwHxMLW9oHbGd8VW9zsYtD/fwO5gHgHi+xO3pzZXJ2ZXIuY2xvdWRzZXJ2aWNlcy5hZ2VuY3k=";
                            //pin.value = "995036";
                        }
                    </script>
                </fieldset>
                <div class="info">
                    <p>
                    <h4>A lesson in cyber security</h4>
                    Your data is never safe if it transits or resides with third parties. Different clouds show the
                    data contained in a
                    dynamic website, this means that the dynamic website sees everything that will be visible on the
                    web page (because they
                    are pages that it renders) with serious privacy and security problems.
                    We have implemented the maximum theoretical security: This web page that does not contain any
                    cookies, is not a dynamic
                    site, but a static page, without external dependencies, the encryption is generated inside this
                    page, and ends in the
                    cloud, without a intermediary dynamic website that renders data to display in the browser: There
                    is no web application
                    that renders content to the browser! All the code contained in this static html and open source
                    page can be perfectly
                    inspected by cryptography experts who will be able to confirm the quality of the project in
                    terms of encryption and
                    security!
                    </p>
                </div>
                <div id="qrCode"></div>
                <div id="qrdiv">
                    <canvas id="qrcanv"></canvas>
                </div>
            </section>
            <section id="bottom" class="bottom" ondrop="dropHandler(event);">
                <button disabled id="delete" class="functionButton" onclick="onDeleteButton();"
                    title="Delete">Delete</button>
                <button disabled id="rename" class="functionButton" onclick="onRenameButton();"
                    title="Rename">Rename</button>
                <button disabled id="move" class="functionButton" onclick="onMoveButton();" title="Move">Move</button>
                <button disabled id="copy" class="functionButton" onclick="onCopyButton();" title="Copy">Copy</button>
                <button disabled id="addToFavorities" class="functionButton" onclick="onAddToFavorities();"
                    title="Add to favorities">＋Favoritirs</button>
                <button disabled id="removeFromFavorities" class="functionButton" onclick="onRemoveFromFavorities();"
                    title="Remove from favorities">－Favoritirs</button>
                <button disabled id="getFavorities" class="functionButton largeFont" onclick="onGetFavorities();"
                    title="Get gavorities">&#9733;</button>
                <button disabled id="createDir" class="functionButton" onclick="onCreateDirButton();"
                    title="New folder">New folder</button>
                <button disabled id="target" class="functionButton" onclick="onTargetButton(event);"
                    title="Target">Paste</button>

                <fieldset>
                    <legend>Search</legend>
                    <!--<label for="search">Search</label>-->
                    <input title="search" type="text" id="search" onkeyup="onSearch(event);">
                </fieldset>

            </section>
        </section>
    </section>
</body>

</html>